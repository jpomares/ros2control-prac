{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introducci\u00f3n e instalaci\u00f3n","text":"<p>Los robots ejecutan m\u00faltiples algoritmos de control simult\u00e1neamente y gestionar todos estos algoritmos de control puede ser complicado. Ros2_control permite ayudar a los desarrolladores a implementar controladores de manera r\u00e1pida y escalable, adem\u00e1s de ofrecer muchas funciones integradas adicionales. As\u00ed, ros2_control es un conjunto de paquetes y herramientas que permiten, b\u00e1sicamente, enviar comandos y comunicarse con las articulaciones de un robot con el objetivo de controlarlas. El principal objetivo de esta pr\u00e1ctica es mostrar como integrar ros2_control en un entorno simulado, de forma que pueda usarse esta herramienta para controlar las articulaciones de un robot.</p> <p>Para desarrollar esta pr\u00e1ctica debe estar instalado ros2_control as\u00ed como una simulaci\u00f3n de un robot RR de dos grados de libertad rotacionales. Se puede utilizar una m\u00e1quina virtual con Ubuntu 24.04 o una instalaci\u00f3n nativa. Por ejemplo, puedes descargar una m\u00e1quina virtual de:</p> <pre><code>https://www.linuxvmimages.com/images/ubuntu-2404/\nhttps://www.osboxes.org/ubuntu/\n</code></pre> <p>A continuaci\u00f3n instalar:</p> <ul> <li>Ros 2 Jazzy Jalisco. Para instalarlo seguir los pasos indicados aqu\u00ed.</li> <li>Ros2_ control: <pre><code>sudo apt install ros-jazzy-gz-ros2-control ros-jazzy-ros2-controllers ros-jazzy-gz-ros2-control-demos\n</code></pre></li> <li>Instalar tambi\u00e9n el siguiente interfaz: <pre><code>sudo apt install ros-jazzy-joint-state-publisher-gui\n</code></pre></li> </ul> <p>Una vez instalado todo, crear una carpeta ros2_ws en el directorio home y dentro de esa carpeta crear otra llamada src: <pre><code>mkdir -p ~/ros2_ws/src\ncd ~/ros2_ws/src\n</code></pre></p> <p>Descomprimir el siguiente zip y copiar la carpeta en la carpeta ros2_robot_sca en el directorio ~/ros2_ws/src que acabas de crear: <pre><code>https://drive.google.com/file/d/12ewBfOP8iy8qGsxEbxkmnFHaRmRGo1lo/view?usp=drive_link\n</code></pre> Este zip contiene la carpeta ros2_robot_sca que contiene la simulaci\u00f3n de un robot de dos grados de libertad que se utilizar\u00e1 a lo largo de la pr\u00e1ctica.</p> <p>Ahora ya se puede compilar el repositorio: <pre><code>cd ~/ros2_ws/\n. /opt/ros/jazzy/setup.sh\ncolcon build\n</code></pre></p>"},{"location":"conceptos_basicos/","title":"Conceptos b\u00e1sicos de ros2_control","text":"<p>En este apartado se va aplicar ros2_control para mover las articulaciones de un robot de 2 grados de libertad. El paquete ros2_control_sca contiene la descripci\u00f3n del robot utilizando Xacro. En este apartado se incorporar\u00e1 la informaci\u00f3n necesaria a la descripci\u00f3n para que pueda ser controlador mediante ros2_control.</p> <p>En primer lugar se compilar\u00e1n los paquetes descargados en  ros2_ws, para ello se utilizar\u00e1 el comando colcon (si no se ha hecho ya anteriormente): <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build\n</code></pre> Adem\u00e1s, despu\u00e9s de compilar, se debe utilizar el comando source sobre el espacio de trabajo para asegurarse de que los paquetes reci\u00e9n a\u00f1adidos sean detectados por ROS2: <pre><code>source install/setup.bash\n</code></pre> Ejecuta el siguiente comando para ver en rviz el modelo simulado del robot que se va a controlar:</p> <p><pre><code>ros2 launch ros2_robot_sca view_robot.launch.py\n</code></pre> </p> <p>El modelo de robot que se ha incorporado al mundo simulado no implementa nada de ros2_control. A continuaci\u00f3n, se describir\u00e1n los pasos a seguir para implementar ros2_control desde cero. Para ello se partir\u00e1 de la descripci\u00f3n del robot en un archivo Xacro. Para agregar ros2_control a nuestro robot, se seguir\u00e1n los siguientes pasos:</p> <ul> <li>Crear un nuevo paquete.</li> <li>Crear un archivo de configuraci\u00f3n para el controller manager y los algoritmos de control.</li> <li>Actualizar el archivo Xacro de la descripci\u00f3n del robot.</li> <li>Crear un archivo de lanzamiento (launch) que inicie los controladores.</li> <li>Probar el robot controlado por ros2_control.</li> </ul>"},{"location":"conceptos_basicos/#crear-un-nuevo-paquete","title":"Crear un nuevo paquete","text":"<p>Cuando se trabaja con ROS, generalmente se recomienda dividir un proyecto rob\u00f3tico en paquetes separados, ya que esto permite un dise\u00f1o modular y minimiza las dependencias entre paquetes. Por lo tanto, comencemos creando un nuevo paquete dedicado exclusivamente a almacenar la configuraci\u00f3n y los archivos de lanzamiento de ros2_control. Para ello, seguir los pasos que se indican a continuaci\u00f3n.</p> <p>Ir al directorio src dentro de ros2_ws: <pre><code>cd ~/ros2_ws/src\n</code></pre> Crear un nuevo paquete llamado my_robot_bringup ejecutando lo siguiente: <pre><code>ros2 pkg create --build-type=ament_cmake my_robot_bringup --dependencies urdf xacro robot_state_publisher\n</code></pre> Esto producir\u00e1 la siguiente salida:</p> <p></p>"},{"location":"conceptos_basicos/#crear-un-archivo-de-configuracion-para-el-controller-manager-y-los-algoritmos-de-control","title":"Crear un archivo de configuraci\u00f3n para el controller manager y los algoritmos de control","text":"<p>Dentro del paquete reci\u00e9n creado, se van a agregar los archivos de configuraci\u00f3n para ros2_control y los controladores que se utilizar\u00e1n. El archivo de configuraci\u00f3n estar\u00e1 dentro de la carpeta config, as\u00ed que se agregar\u00e1 esa carpeta a nuestro paquete: <pre><code>cd ~/ros2_ws/src/my_robot_bringup\n</code></pre></p> <pre><code>mkdir config\n</code></pre> <p>En la carpeta config crear un archivo llamado controller_configuration.yaml: <pre><code>touch ~/ros2_ws/src/my_robot_bringup/config/controller_configuration.yaml\n</code></pre> A\u00f1adirle el siguiente contenido: <pre><code># Controller manager configuration\ncontroller_manager:\n  ros__parameters:\n    update_rate: 10  # Hz\n\n    ### Controllers available\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    forward_position_controller:\n      type: forward_command_controller/ForwardCommandController\n\n    joint_trajectory_controller:\n      type: joint_trajectory_controller/JointTrajectoryController\n\n\n### Properties of the controllers that we will use and definition of joints to use ###\nforward_position_controller:\n  ros__parameters:\n    joints:\n      - joint1\n    interface_name: position\n\n\njoint_trajectory_controller:\n  ros__parameters:\n    joints:\n      - joint1\n\n    command_interfaces:\n      - position\n\n    state_interfaces:\n      - position\n\n    state_publish_rate: 200.0 # Hz, Defaults to 50\n    action_monitor_rate: 20.0 # Hz, Defaults to 20\n\n    allow_partial_joints_goal: false # Defaults to false\n    open_loop_control: true\n    allow_integration_in_goal_trajectories: true\n    constraints:\n      stopped_velocity_tolerance: 0.01 # Defaults to 0.01\n      goal_time: 0.0 # Defaults to 0.0 (start immediately)\n</code></pre></p> <p>A continuaci\u00f3n, se describir\u00e1 este c\u00f3digo por partes:</p> <pre><code># Controller manager configuration\ncontroller_manager:\n  ros__parameters:\n    update_rate: 10  # Hz\n</code></pre> <p>Los archivos de configuraci\u00f3n de ros2_control son simplemente archivos de par\u00e1metros t\u00edpicos para ROS2. Como tal, la primera l\u00ednea debe especificar el nombre del nodo de ROS2 (controller_manager) y la segunda l\u00ednea debe ser ros__parameters: con una indentaci\u00f3n. Luego, en otro nivel de indentaci\u00f3n, configuramos el controller manager estableciendo la frecuencia del bucle de control a 10 Hz. La frecuencia del bucle  de control es uno de los par\u00e1metros que se puede ajustar para obtener el comportamiento esperado en nuestros actuadores.</p> <pre><code>    ### Controllers available\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    forward_position_controller:\n      type: forward_command_controller/ForwardCommandController\n\n    joint_trajectory_controller:\n      type: joint_trajectory_controller/JointTrajectoryController\n</code></pre> <p>Despu\u00e9s, al mismo nivel de indentaci\u00f3n, definimos los controladores que queremos tener disponibles. Para definir un controlador, debemos proporcionar un nombre \u00fanico (que podemos elegir libremente) seguido de dos puntos, y en la siguiente l\u00ednea ingresamos un tipo de controlador, de la misma manera que en este nuevo ejemplo mostrado aqu\u00ed:</p> <pre><code>    joint1_position_controller:\n      type: effort_controllers/JointGroupEffortController\n</code></pre> <p>El tipo de controlador, se refiere al nombre del plugin ros2_control que se utilizar\u00e1. Se puede hacer referencia al nombre de los plugins de controladores comunes proporcionados por el paquete ros2_controllers, los cuales se han descrito anteriormente. Tambi\u00e9n es posible crear un plugin de controlador personalizado y asignarle un nombre a tu elecci\u00f3n como se describir\u00e1 m\u00e1s adelante. El resto del archivo de configuraci\u00f3n es el siguiente:</p> <pre><code>### Properties of the controllers that we will use and definition of joints to use ###\nforward_position_controller:\n  ros__parameters:\n    joints:\n      - joint1\n    interface_name: position\n\n\njoint_trajectory_controller:\n  ros__parameters:\n    joints:\n      - joint1\n\n    command_interfaces:\n      - position\n\n    state_interfaces:\n      - position\n\n    state_publish_rate: 200.0 # Hz, Defaults to 50\n    action_monitor_rate: 20.0 # Hz, Defaults to 20\n\n    allow_partial_joints_goal: false # Defaults to false\n    open_loop_control: true\n    allow_integration_in_goal_trajectories: true\n    constraints:\n      stopped_velocity_tolerance: 0.01 # Defaults to 0.01\n      goal_time: 0.0 # Defaults to 0.0 (start immediately)\n</code></pre> <p>Finalmente, al nivel de indentaci\u00f3n ra\u00edz, debemos incluir los par\u00e1metros requeridos por los controladores que queremos tener disponibles. En el c\u00f3digo de arriba, hay dos controladores cuyas propiedades est\u00e1n siendo definidas. Recuerda que nombramos esos controladores: forward_position_controller y joint_trajectory_controller.</p> <p>Las propiedades espec\u00edficas y valores de par\u00e1metros que se definen para cada controlador se explicaron anteriormente. Uno de los par\u00e1metros de configuraci\u00f3n m\u00e1s importantes que se debe definir es el nombre de las articulaciones que ser\u00e1n controladas por cada controlador, que son estas dos l\u00edneas aqu\u00ed:</p> <pre><code>    joints:\n      - joint1\n</code></pre> <p>Importante: los nombres de las articulaciones que se definen en este archivo de configuraci\u00f3n deben coincidir con los nombres de las articulaciones en el archivo URDF/Xacro. El archivo yaml de arriba, por ejemplo, asigna una articulaci\u00f3n con el nombre \"joint1\" a ambos controladores. \"joint1\" corresponde al nombre de la articulaci\u00f3n definido por la etiqueta XML  dentro del archivo .xacro (rrbot_description.urdf.xacro en la carpeta ros2_ws/src/ros2_robot_sca/description/rrbot/urdf)."},{"location":"conceptos_basicos/#actualizar-el-archivo-xacro-de-la-descripcion-del-robot","title":"Actualizar el archivo Xacro de la descripci\u00f3n del robot","text":"<p>Para habilitar ros2_control, tambi\u00e9n debemos agregar algunos nuevos elementos XML al archivo URDF o Xacro que describa el robot. En esta secci\u00f3n, se describe c\u00f3mo modificar un archivo de descripci\u00f3n de robot existente.</p> <p>Para ello, en primer lugar se describir\u00e1 la estructura de los ficheros xacro que definen el robot. El fichero xacro principal es rrbot.urdf.xacro que se encuentra en ros2_robot_sca/description/urdf. El contenido de este fichero es: <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;!-- Revolute-Revolute Manipulator --&gt;\n&lt;!--\nCopied and modified from ROS1 example -\nhttps://github.com/ros-simulation/gazebo_ros_demos/blob/kinetic-devel/rrbot_description/urdf/rrbot.xacro\n--&gt;\n&lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"2dof_robot\"&gt;\n  &lt;xacro:arg name=\"prefix\" default=\"\" /&gt;\n  &lt;xacro:arg name=\"use_gazebo\" default=\"false\" /&gt;\n\n  &lt;!-- Import RRBot macro --&gt;\n  &lt;xacro:include filename=\"$(find ros2_robot_sca)/rrbot/urdf/rrbot_description.urdf.xacro\" /&gt;\n\n  &lt;!-- Import Rviz colors --&gt;\n  &lt;xacro:include filename=\"$(find ros2_robot_sca)/rrbot/urdf/rrbot.materials.xacro\" /&gt;\n\n  &lt;!-- Used for fixing robot --&gt;\n  &lt;link name=\"world\"/&gt;\n\n  &lt;xacro:rrbot parent=\"world\" prefix=\"$(arg prefix)\"&gt;\n    &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\" /&gt;\n  &lt;/xacro:rrbot&gt;\n\n&lt;/robot&gt;\n</code></pre></p> <p>Se observa que se importan una serie de macros que definir\u00e1n las caracter\u00edsticas del robot:</p> <ul> <li><code>&lt;xacro:include filename=\"$(find ros2_robot_sca)/rrbot/urdf/rrbot_description.urdf.xacro\" /&gt;</code>. Aqu\u00ed se definen las articulaciones y dimensiones del robot (inercia, caracter\u00edsticas geom\u00e9tricas, etc).</li> <li><code>&lt;xacro:include filename=\"$(find ros2_robot_sca)/rrbot/urdf/rrbot.materials.xacro\" /&gt;</code>. Aqu\u00ed se definen los materiales y colores de los eslabones.</li> </ul> <p>A continuaci\u00f3n definir una nueva macro que incluir\u00e1 los tags de ros2_control necesarios para controlar las articulaciones. Para ello, a\u00f1adir el siguiente c\u00f3digo justo debajo de las 2 l\u00edneas anteriores: <pre><code>&lt;!-- Import RRBot ros2_control description --&gt;\n  &lt;xacro:include filename=\"$(find ros2_robot_sca)/ros2_control/rrbot.ros2_control.xacro\" /&gt;\n</code></pre> Adem\u00e1s, en la carpeta ros2_control del paquete ros2_robot_sca/description/ros2_control/ se deber\u00e1 crear el fichero rrbot.ros2_control.xacro: <pre><code>touch ~/ros2_ws/src/ros2_robot_sca/description/ros2_control/rrbot.ros2_control.xacro\n</code></pre> Incluir el siguiente c\u00f3digo en el archivo anterior: <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt;\n\n  &lt;xacro:macro name=\"rrbot_ros2_control\" params=\"name prefix use_gazebo:=^|false\"&gt;\n\n    &lt;ros2_control name=\"${name}\" type=\"system\"&gt;\n      &lt;hardware&gt;\n        &lt;xacro:if value=\"${use_gazebo}\"&gt;\n          &lt;plugin&gt;gz_ros2_control/GazeboSimSystem&lt;/plugin&gt;\n        &lt;/xacro:if&gt;\n        &lt;xacro:unless value=\"${use_gazebo}\"&gt;\n          &lt;plugin&gt;ros2_robot_sca/RRBotSystemPositionOnlyHardware&lt;/plugin&gt;\n          &lt;param name=\"example_param_hw_start_duration_sec\"&gt;0&lt;/param&gt;\n          &lt;param name=\"example_param_hw_stop_duration_sec\"&gt;3.0&lt;/param&gt;\n          &lt;param name=\"example_param_hw_slowdown\"&gt;100&lt;/param&gt;\n        &lt;/xacro:unless&gt;\n      &lt;/hardware&gt;\n\n      &lt;joint name=\"${prefix}joint1\"&gt;\n        &lt;command_interface name=\"position\"&gt;\n          &lt;param name=\"min\"&gt;-1&lt;/param&gt;\n          &lt;param name=\"max\"&gt;1&lt;/param&gt;\n        &lt;/command_interface&gt;\n        &lt;state_interface name=\"position\"/&gt;\n      &lt;/joint&gt;\n      &lt;joint name=\"${prefix}joint2\"&gt;\n        &lt;command_interface name=\"position\"&gt;\n          &lt;param name=\"min\"&gt;-1&lt;/param&gt;\n          &lt;param name=\"max\"&gt;1&lt;/param&gt;\n        &lt;/command_interface&gt;\n        &lt;state_interface name=\"position\"/&gt;\n      &lt;/joint&gt;\n    &lt;/ros2_control&gt;\n\n  &lt;/xacro:macro&gt;\n\n&lt;/robot&gt;\n</code></pre></p> <p>Este fichero incorpora los siguientes tags: <pre><code>&lt;ros2_control name=\"${name}\" type=\"system\"&gt;\n</code></pre> El framework ros2_control utiliza la etiqueta <code>&lt;ros2_control&gt;</code> en el archivo URDF del robot para describir sus componentes y sus funciones. <pre><code>&lt;xacro:if value=\"${use_gazebo}\"&gt;\n    &lt;plugin&gt;gz_ros2_control/GazeboSimSystem&lt;/plugin&gt;\n&lt;/xacro:if&gt;           \n</code></pre> El elemento  es necesario para definir la interfaz de hardware de ros2_control, que conectar\u00e1 los controladores con los actuadores. En este ejemplo, se utiliza gz_ros2_control/GazeboSimSystem como interfaz de hardware porque se quiere utilizar ros2_control para nuestro robot simulado en Gazebo. En los siguientes apartados, se describir\u00e1 m\u00e1s detalles de las interfaces hardware.  <p><pre><code>&lt;joint name=\"${prefix}joint1\"&gt;\n    &lt;command_interface name=\"position\"&gt;\n        &lt;param name=\"min\"&gt;-1&lt;/param&gt;\n        &lt;param name=\"max\"&gt;1&lt;/param&gt;\n    &lt;/command_interface&gt;\n    &lt;state_interface name=\"position\"/&gt;\n&lt;/joint&gt;\n</code></pre> Este bloque de etiquetas XML agrega un elemento <code>&lt;joint name=\" \"&gt;</code> como un elemento hijo de la etiqueta <code>&lt;ros2_control&gt;</code>. El elemento <code>&lt;joint name=\" \"&gt;</code> se usa para definir qu\u00e9 interfaces de comando e interfaces de estado est\u00e1n habilitadas para cada articulaci\u00f3n. Por ejemplo, aqu\u00ed se define una \u00fanica interfaz de comando que solo permite enviar \u00f3rdenes de posici\u00f3n a las articulaciones. Pero tambi\u00e9n se podr\u00eda optar por agregar una segunda interfaz de comando que permita controlar velocidades. Lo mismo aplica a las interfaces de estado. Usando la etiqueta <code>&lt;state_interface name=\"...\"/&gt;</code>, se define qu\u00e9 magnitudes del estado de la articulaci\u00f3n (por ejemplo, posici\u00f3n, velocidad, esfuerzo, aceleraci\u00f3n, etc.) estar\u00e1n disponibles (transmitidas) por ros2_control para cada articulaci\u00f3n.</p> <p>Repitiendo la estructura mostrada anteriormente, se agrega tantos elementos <code>&lt;joint name=\" \"&gt;</code> como articulaciones reales tenga el robot. Luego, dentro de cada uno, se define tantas interfaces de comando e interfaces de estado como necesite nuestro controlador y como soporte el hardware del robot.</p> <p>Por \u00faltimo, como queremos ejecutar una simulaci\u00f3n en Gazebo, tambi\u00e9n se necesita iniciar un plugin para Gazebo. A\u00f1adir este c\u00f3digo al final de rrbot.urdf.xacro pero antes de cerrar /robot&gt;: <pre><code>  &lt;xacro:rrbot_ros2_control\n    name=\"RRBot\" prefix=\"$(arg prefix)\" use_gazebo=\"$(arg use_gazebo)\"/&gt;\n\n  &lt;xacro:if value=\"$(arg use_gazebo)\"&gt;\n    &lt;!-- Import Gazebo Classic definitions + plugin --&gt;\n    &lt;xacro:include filename=\"$(find ros2_robot_sca)/gazebo/rrbot.gazebo.xacro\" /&gt;\n    &lt;xacro:rrbot_gazebo prefix=\"$(arg prefix)\"/&gt;\n  &lt;/xacro:if&gt;\n</code></pre></p> <p>Ten en cuenta que estas etiquetas XML no son necesarias para ros2_control, sino para Gazebo. Este c\u00f3digo carga el fichero rrbot.gazebo.xacro que se encuentra en ros2_ws/src/ros2_robot_sca/description/gazebo. Crear ese fichero mediante el comando:</p> <p><pre><code>touch ~/ros2_ws/src/ros2_robot_sca/description/gazebo/rrbot.gazebo.xacro\n</code></pre> Incluir el siguiente c\u00f3digo en el archivo anterior:</p> <p><pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;!--\nCopied and modified from ROS1 example -\nhttps://github.com/ros-simulation/gazebo_ros_demos/blob/kinetic-devel/rrbot_description/urdf/rrbot.gazebo\n--&gt;\n&lt;robot xmlns:xacro=\"http://ros.org/wiki/xacro\"&gt;\n\n  &lt;xacro:macro name=\"rrbot_gazebo\" params=\"prefix\"&gt;\n\n    &lt;!-- ros_control plugin --&gt;\n    &lt;gazebo&gt;\n      &lt;plugin filename=\"gz_ros2_control-system\" name=\"gz_ros2_control::GazeboSimROS2ControlPlugin\"&gt;\n        &lt;parameters&gt;$(find my_robot_bringup)/config/controller_configuration.yaml&lt;/parameters&gt;\n      &lt;/plugin&gt;\n    &lt;/gazebo&gt;\n\n    &lt;!-- Link1 --&gt;\n    &lt;gazebo reference=\"${prefix}base_link\"&gt;\n      &lt;material&gt;Gazebo/Orange&lt;/material&gt;\n    &lt;/gazebo&gt;\n\n    &lt;!-- Link2 --&gt;\n    &lt;gazebo reference=\"${prefix}link1\"&gt;\n      &lt;mu1&gt;0.2&lt;/mu1&gt;\n      &lt;mu2&gt;0.2&lt;/mu2&gt;\n      &lt;material&gt;Gazebo/Yellow&lt;/material&gt;\n    &lt;/gazebo&gt;\n\n    &lt;!-- Link3 --&gt;\n    &lt;gazebo reference=\"${prefix}link2\"&gt;\n      &lt;mu1&gt;0.2&lt;/mu1&gt;\n      &lt;mu2&gt;0.2&lt;/mu2&gt;\n      &lt;material&gt;Gazebo/Orange&lt;/material&gt;\n    &lt;/gazebo&gt;\n\n  &lt;/xacro:macro&gt;\n\n&lt;/robot&gt;\n</code></pre> Observa que dentro de la etiqueta <code>&lt;gazebo&gt;&lt;plugin&gt;</code>, tenemos un elemento <code>&lt;parameter&gt;</code>, que se utiliza para cargar el archivo de configuraci\u00f3n .yaml creado en la secci\u00f3n anterior. Por lo tanto, recuerda: cuando se ejecuta ros2_control con un robot simulado en Gazebo, se pasa el archivo de configuraci\u00f3n .yaml del controlador aqu\u00ed, dentro de las etiquetas del plugin de Gazebo.</p>"},{"location":"conceptos_basicos/#crear-un-archivo-de-lanzamiento-launch-que-inicie-los-controladores","title":"Crear un archivo de lanzamiento (launch) que inicie los controladores","text":"<p>Con el archivo de configuraci\u00f3n listo y el archivo URDF actualizado, es momento de crear un archivo de lanzamiento para generar el nuevo robot y los controladores. Para ello, ejecutar los siguientes comandos: <pre><code>cd ~/ros2_ws/src/my_robot_bringup\n</code></pre></p> <pre><code>mkdir launch\n</code></pre> <p>Crea un nuevo archivo my_robot.launch.py dentro del directorio launch, siguiendo las instrucciones: <pre><code>cd launch\n</code></pre></p> <pre><code>touch my_robot.launch.py\n</code></pre> <pre><code>chmod +x my_robot.launch.py\n</code></pre> <p>Introducir el siguiente C\u00f3digo en el fichero reci\u00e9n creado: <pre><code>from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.conditions import IfCondition\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import Command, FindExecutable, PathJoinSubstitution, LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\n\ndef generate_launch_description():\n\n    # Declare arguments\n    declared_arguments = []\n    declared_arguments.append(\n        DeclareLaunchArgument(\n            \"gui\",\n            default_value=\"false\",\n            description=\"Start Gazebo automatically with this launch file.\",\n        )\n    )\n\n    # Initialize Arguments\n    gui = LaunchConfiguration(\"gui\")\n\n    # gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            [FindPackageShare(\"ros_gz_sim\"), \"/launch/gz_sim.launch.py\"]\n        ),\n        launch_arguments={\"gz_args\": \" -r -v 3 empty.sdf\"}.items(),\n    )\n\n    gz_spawn_entity = Node(\n        package=\"ros_gz_sim\",\n        executable=\"create\",\n        output=\"screen\",\n        arguments=[\n            \"-topic\",\n            \"/robot_description\",\n            \"-name\",\n            \"rrbot_system_position\",\n            \"-allow_renaming\",\n            \"true\",\n        ],\n    )\n\n    # Get URDF via xacro\n    robot_description_content = Command(\n        [\n            PathJoinSubstitution([FindExecutable(name=\"xacro\")]),\n            \" \",\n            PathJoinSubstitution(\n                [FindPackageShare(\"ros2_robot_sca\"), \"urdf\", \"rrbot.urdf.xacro\"]\n            ),\n            \" \",\n            \"use_gazebo:=true\",\n        ]\n    )\n    robot_description = {\"robot_description\": robot_description_content}\n\n    robot_controllers = PathJoinSubstitution(\n        [\n            FindPackageShare(\"my_robot_bringup\"),\n            \"config\",\n            \"controller_configuration.yaml\",\n        ]\n    )\n\n    rviz_config_file = PathJoinSubstitution(\n        [FindPackageShare(\"ros2_robot_sca\"), \"rrbot/rviz\", \"rrbot.rviz\"]\n    )\n\n    node_robot_state_publisher = Node(\n        package=\"robot_state_publisher\",\n        executable=\"robot_state_publisher\",\n        output=\"screen\",\n        parameters=[robot_description],\n    )\n\n    joint_state_broadcaster_spawner = Node(\n        package=\"controller_manager\",\n        executable=\"spawner\",\n        arguments=[\"joint_state_broadcaster\"],\n    )\n\n    robot_controller_spawner = Node(\n        package=\"controller_manager\",\n        executable=\"spawner\",\n        arguments=[\"forward_position_controller\", \"--param-file\", robot_controllers],\n    )\n\n    nodes = [\n        gazebo,\n        node_robot_state_publisher,\n        gz_spawn_entity,\n        joint_state_broadcaster_spawner,\n        robot_controller_spawner,\n    ]\n\n    return LaunchDescription(declared_arguments + nodes)\n</code></pre></p> <p>A continuaci\u00f3n, se describir\u00e1 el fichero launch por partes:</p> <pre><code>from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.conditions import IfCondition\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import Command, FindExecutable, PathJoinSubstitution, LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n</code></pre> <p>Agregar estas declaraciones de importaci\u00f3n nos permitir\u00e1 utilizar las funciones definidas dentro de estos m\u00f3dulos. <pre><code>def generate_launch_description():\n</code></pre> Aqu\u00ed definimos una funci\u00f3n que retornar\u00e1 un objeto LaunchDescription. <pre><code>gz_spawn_entity = Node(\n    package=\"ros_gz_sim\",\n    executable=\"create\",\n    output=\"screen\",\n    arguments=[\n        \"-topic\",\n        \"/robot_description\",\n        \"-name\",\n        \"rrbot_system_position\",\n        \"-allow_renaming\",\n        \"true\",\n    ],\n)\n</code></pre> Este c\u00f3digo sirve para generar en Gazebo la versi\u00f3n actualizada del modelo del robot (que incluye los elementos de ros2_control).</p> <p><pre><code>robot_description_content = Command(\n    [\n        PathJoinSubstitution([FindExecutable(name=\"xacro\")]),\n        \" \",\n        PathJoinSubstitution(\n            [FindPackageShare(\"ros2_robot_sca\"), \"urdf\", \"rrbot.urdf.xacro\"]\n        ),\n         \",\n        \"use_gazebo:=true\",\n    ]\n)\nrobot_description = {\"robot_description\": robot_description_content}\n</code></pre> En ROS2, usamos el m\u00f3dulo xacro de Python con un c\u00f3digo como el anterior para analizar archivos xacro directamente en el archivo de lanzamiento. B\u00e1sicamente, esto carga el modelo del robot definido dentro del archivo xacro y lo almacena en la variable robot_description para su uso posterior.</p> <p><pre><code>node_robot_state_publisher = Node(\n    package=\"robot_state_publisher\",\n    executable=\"robot_state_publisher\",\n    output=\"screen\",\n    parameters=[robot_description],\n)\n</code></pre> En este c\u00f3digo se genera un nodo robot_state_publisher, proporcionando la variable robot_description como par\u00e1metro. Este nodo lee el topic /joint_states del joint_state_broadcaster y proporciona una realimentaci\u00f3n continua de las ubicaciones de las articulaciones del robot a trav\u00e9s de los topics tf y tf_static. <pre><code>joint_state_broadcaster_spawner = Node(\n    package=\"controller_manager\",\n    executable=\"spawner\",\n    arguments=[\"joint_state_broadcaster\"],\n)\n</code></pre> Aqu\u00ed se utiliza un script de Python llamado spawner, que es proporcionado por el paquete controller_manager, para cargar e iniciar el joint_state_broadcaster. </p> <p>El joint_state_broadcaster publica el estado del robot en los topics \"/rrbot_controller/state\" y \"/joint_states\". El estado del robot, descrito por la posici\u00f3n, velocidad y esfuerzo de cada articulaci\u00f3n, se transmite como un mensaje \"sensor_msgs/JointState\" de ROS2, que puede ser le\u00eddo por cualquier nodo de ROS2. <pre><code>robot_controller_spawner = Node(\n    package=\"controller_manager\",\n    executable=\"spawner\",\n    arguments=[\"forward_position_controller\", \"--param-file\", robot_controllers],\n)\n</code></pre> Aqu\u00ed se utiliza el mismo script que antes para cargar e iniciar un forward_position_controller (que se ha definido anteriormente en el fichero controller_configuration.yaml). Con este controlador cargado, se puede enviar comandos de posici\u00f3n a las articulaciones del robot.</p> <p>A continuaci\u00f3n, es necesario asegurarse que ROS reconoce el fichero launch que acabamos de crear. Para ello, abrir el fichero CMakeLists.txt (del paquete my_robot_bringup) y a\u00f1adir un comando install(DIRECTORY...) al final del fichero: <pre><code>install(\n  DIRECTORY\n    launch\n    config\n  DESTINATION\n    share/${PROJECT_NAME}/\n)\n</code></pre> Esto le indica a colcon build que coloque una copia o un enlace tanto de la carpeta launch como del archivo de configuraci\u00f3n YAML en el directorio share. Este directorio es el lugar predeterminado donde ROS2 buscar\u00e1 elementos como archivos de lanzamiento. Aseg\u00farate de guardar todo y ejecuta colcon build: <pre><code>cd ~/ros2_ws\n</code></pre></p> <pre><code>colcon build\n</code></pre> <pre><code>source install/setup.bash\n</code></pre>"},{"location":"conceptos_basicos/#probar-el-robot-controlado-por-ros2_control","title":"Probar el robot controlado por ros2_control","text":"<p>En este apartado se va a comprobar si todo funciona correctamente. Para ello, ejecutar el comando ros2 launch en un terminal: <pre><code>ros2 launch my_robot_bringup my_robot.launch.py\n</code></pre> Se mostrar\u00e1 un mensaje en la consola confirmando que tanto joint_state_broadcaster como forward_position_controller han sido cargados, configurados e iniciados.</p> <p></p> <p>Ahora deber\u00edas ver el modelo del robot aparecer en Gazebo:</p> <p></p> <p>A continuaci\u00f3n, se va a comprobar los topics disponibles para enviar comandos. Para ello, abrir un nuevo terminal y ejecutar los siguientes comandos: <pre><code>cd ~/ros2_ws\nsource install/setup.bash\nros2 topic list\n</code></pre> Entre otros, deber\u00edas ver que el siguiente topic est\u00e1 disponible, que lo utilizaremos para enviar comandos al robot: <pre><code>/forward_position_controllers/commands\n</code></pre> </p> <p>Podemos usar este comando para publicar datos en el topic (se mueve la primera articulaci\u00f3n a la posici\u00f3n 0.79 en radianes): <pre><code>ros2 topic pub /forward_position_controller/commands std_msgs/msg/Float64MultiArray \"data:\n- 0.79\" -1\n</code></pre> Si todo ha ido bien deber\u00edas ver lo siguiente:</p> <p></p> <p>Con solo unos pocos pasos de configuraci\u00f3n y sin necesidad de desarrollo, ahora podemos mover el robot publicando comandos en un topic. Nuestro robot ya puede interactuar con todo el ecosistema de ROS2.</p>"},{"location":"conceptos_basicos/#ejercicio","title":"Ejercicio","text":"<p>Ejercicio</p> <p>Para aplicar lo aprendido, en este ejercicio tendremos que indicarle a ros2_control que tambi\u00e9n queremos controlar la segunda articulaci\u00f3n del robot, la que tiene el nombre joint2. Para eso, se deber\u00e1n modificar los archivos en los que has trabajado hasta ahora y ampliarlos para agregar la segunda articulaci\u00f3n, de modo que al final puedas mover ambas articulaciones en el robot simulado usando ros2_control.</p> <p>Una vez hecho esto, ejecutar el siguiente comando en una terminal: <pre><code>ros2 launch my_robot_bringup my_robot.launch.py\n</code></pre> En otra terminal ejecutar los siguientes comandos: <pre><code>ros2 topic pub /forward_position_controller/commands std_msgs/msg/Float64MultiArray \"data:\n- 1.57\n- -1.57\" -1\n</code></pre> <pre><code>ros2 topic pub /forward_position_controller/commands std_msgs/msg/Float64MultiArray \"data:\n- -1.57\n- 0.79\" -1\n</code></pre> Los comandos anteriores deber\u00edan colocar el robot en las siguientes posiciones:</p> <p> </p>"},{"location":"controlador_propio/","title":"Creaci\u00f3n de nuevos controladores","text":"<p>Este apartado describe c\u00f3mo escribir un nuevo controlador personalizado que toma se\u00f1ales de entrada y genera las se\u00f1ales de control enviadas a los actuadores utilizando ros2_control.</p>"},{"location":"controlador_propio/#introduccion","title":"Introduccion","text":"<p>Los controladores son el n\u00facleo del sistema ros2_control. El paquete ros2_controllers incluye un conjunto de controladores est\u00e1ndar comunes y completos que satisfacen muchos casos de uso habituales. Algunos ejemplos de estos controladores son el controlador de esfuerzo, el controlador de trayectoria y el controlador de accionamiento diferencial, y la lista de controladores proporcionados crece con cada versi\u00f3n de ROS2. Sin embargo, si bien algunos controladores se pueden aplicar ampliamente a muchos tipos diferentes de aplicaciones rob\u00f3ticas, tambi\u00e9n es cierto que algunas aplicaciones tambi\u00e9n requieren controladores espec\u00edficos, seg\u00fan la naturaleza y los requisitos de una aplicaci\u00f3n.</p> <p>Afortunadamente, ros2_control es lo suficientemente flexible como para permitir crear controladores personalizados para ampliar su funcionalidad. De esta manera, tambi\u00e9n se puede usar ros2_control para resolver problemas de control m\u00e1s complejos sin demasiados problemas. En este apartado, se describir\u00e1 c\u00f3mo crear un controlador personalizado. </p>"},{"location":"controlador_propio/#controlador-propio-en-5-pasos","title":"Controlador propio en 5 pasos","text":"<p>Para implementar un nuevo controlador se deber\u00e1n seguir los siguientes pasos:</p> <ul> <li>Crear un paquete para el controlador personalizado.</li> <li>Escribir un archivo de encabezado .hpp.</li> <li>Definir un archivo fuente el controlador .cpp.</li> <li>Preparar los archivos CMakeLists.txt y package.xml para la compilaci\u00f3n.</li> <li>Registrar el controlador como un plugin.</li> </ul>"},{"location":"controlador_propio/#crear-un-paquete-para-el-controlador-personalizado","title":"Crear un paquete para el controlador personalizado","text":"<p>Como es habitual, el enfoque recomendado es configurar un nuevo paquete para mantener nuestro nuevo controlador modular e intercambiable.</p> <p>Primero, ir al directorio src dentro de ros2_ws:</p> <pre><code>cd ~/ros2_ws/src\n</code></pre> <p>Ahora crea el nuevo paquete. Este nuevo paquete debe tener ament_cmake como tipo de compilaci\u00f3n y, como pr\u00e1ctica recomendada, se sugiere terminar el nombre del nuevo paquete con \"_controller\". Tambi\u00e9n se necesitar\u00e1n unas cuantas dependencias:</p> <ul> <li>control_msgs</li> <li>controller_interface</li> <li>hardware_interface</li> <li>pluginlib</li> <li>rclcpp</li> <li>rclcpp_lifecycle</li> <li>realtime_tools</li> <li>example_interfaces</li> </ul> <p>Ejecutar el siguiente comando:</p> <p><pre><code>ros2 pkg create --build-type=ament_cmake rrbot_controller --dependencies control_msgs controller_interface hardware_interface pluginlib rclcpp rclcpp_lifecycle realtime_tools example_interfaces\n</code></pre> El directorio del nuevo paquete ahora deber\u00eda tener un archivo CMakeLists.txt y un archivo package.xml y un directorio src y un directorio include/rrbot_controller.</p>"},{"location":"controlador_propio/#escribir-un-archivo-de-encabezado-hpp","title":"Escribir un archivo de encabezado .hpp","text":"<p>Ahora, dentro de la carpeta include/rrbot_controller, crear un archivo llamado rrbot_controller.hpp.</p> <pre><code>touch ~/ros2_ws/src/rrbot_controller/include/rrbot_controller/rrbot_controller.hpp\n</code></pre> <p>Luego a\u00f1adir el siguiente fragmento de c\u00f3digo en ese archivo:</p> <pre><code>// Copyright (c) 2021, Bence Magyar and Denis Stogl\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef RRBOT_CONTROLLER__RRBOT_CONTROLLER_HPP_\n#define RRBOT_CONTROLLER__RRBOT_CONTROLLER_HPP_\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"controller_interface/controller_interface.hpp\"\n#include \"rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp\"\n#include \"rclcpp_lifecycle/state.hpp\"\n#include \"realtime_tools/realtime_buffer.hpp\"\n#include \"realtime_tools/realtime_publisher.hpp\"\n\n#include \"control_msgs/msg/joint_controller_state.hpp\"\n#include \"control_msgs/msg/joint_jog.hpp\"\n\nnamespace rrbot_controller {\nusing CallbackReturn =\n    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;\n\nclass RRBotController : public controller_interface::ControllerInterface {\npublic:\n  RRBotController();\n\n  CallbackReturn on_init() override;\n\n  controller_interface::InterfaceConfiguration\n  command_interface_configuration() const override;\n\n  controller_interface::InterfaceConfiguration\n  state_interface_configuration() const override;\n\n  CallbackReturn\n  on_configure(const rclcpp_lifecycle::State &amp;previous_state) override;\n\n  CallbackReturn\n  on_activate(const rclcpp_lifecycle::State &amp;previous_state) override;\n\n  CallbackReturn\n  on_deactivate(const rclcpp_lifecycle::State &amp;previous_state) override;\n\n  controller_interface::return_type\n  update(const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period) override;\n\nprotected:\n  std::vector&lt;std::string&gt; joint_names_;\n  std::string interface_name_;\n\n  // Command subscribers and Controller State publisher\n  using ControllerCommandMsg = control_msgs::msg::JointJog;\n\n  rclcpp::Subscription&lt;ControllerCommandMsg&gt;::SharedPtr command_subscriber_ =\n      nullptr;\n  realtime_tools::RealtimeBuffer&lt;std::shared_ptr&lt;ControllerCommandMsg&gt;&gt;\n      input_command_;\n\n  using ControllerStateMsg = control_msgs::msg::JointControllerState;\n  using ControllerStatePublisher =\n      realtime_tools::RealtimePublisher&lt;ControllerStateMsg&gt;;\n\n  rclcpp::Publisher&lt;ControllerStateMsg&gt;::SharedPtr s_publisher_;\n  std::unique_ptr&lt;ControllerStatePublisher&gt; state_publisher_;\n};\n\n} // namespace rrbot_controller\n\n#endif // RRBOT_CONTROLLER__RRBOT_CONTROLLER_HPP_\n</code></pre>"},{"location":"controlador_propio/#explicacion-del-codigo","title":"Explicaci\u00f3n del c\u00f3digo","text":"<p>A continuaci\u00f3n se va a describir este c\u00f3digo por trozos. <pre><code>#ifndef RRBOT_CONTROLLER__RRBOT_CONTROLLER_HPP_\n#define RRBOT_CONTROLLER__RRBOT_CONTROLLER_HPP_\n</code></pre> Este c\u00f3digo de encabezado asegura que no se incluya m\u00e1s de una vez.</p> <pre><code>#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"controller_interface/controller_interface.hpp\"\n#include \"rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp\"\n#include \"rclcpp_lifecycle/state.hpp\"\n#include \"realtime_tools/realtime_buffer.h\"\n#include \"realtime_tools/realtime_publisher.h\"\n// #include \"rrbot_controller/visibility_control.h\"\n\n#include \"control_msgs/msg/joint_controller_state.hpp\"\n#include \"control_msgs/msg/joint_jog.hpp\"\n</code></pre> <p>Se utilizan las directivas #include para incluir el contenido de los archivos especificados en el compilador.</p> <pre><code>using CallbackReturn = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;\n</code></pre> <p>Esto nos permitir\u00e1 usar las formas abreviadas CallbackReturn::SUCCESS y CallbackReturn::ERROR en lugar del nombre de espacio de nombres completo rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS m\u00e1s adelante en el c\u00f3digo. <pre><code>namespace rrbot_controller\n</code></pre> Esto permite poner nuestra implementaci\u00f3n en un espacio de nombres que coincida con el nombre del paquete. <pre><code>class RRBotController : public controller_interface::ControllerInterface\n</code></pre> Aqu\u00ed solo estamos declarando la clase RRBotController, que hereda de la clase controller_interface::ControllerInterface. Esta \u00faltima es la clase de la que todo controlador personalizado debe heredar para poder ser construido correctamente.</p> <pre><code>public:\n  RRBotController();\n\n  CallbackReturn on_init() override;\n\n  controller_interface::InterfaceConfiguration\n  command_interface_configuration() const override;\n\n  controller_interface::InterfaceConfiguration\n  state_interface_configuration() const override;\n\n  CallbackReturn\n  on_configure(const rclcpp_lifecycle::State &amp;previous_state) override;\n\n  CallbackReturn\n  on_activate(const rclcpp_lifecycle::State &amp;previous_state) override;\n\n  CallbackReturn\n  on_deactivate(const rclcpp_lifecycle::State &amp;previous_state) override;\n\n  controller_interface::return_type\n  update(const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period) override;\n</code></pre> <p>Despu\u00e9s, debemos declarar estos m\u00e9todos p\u00fablicos, que son los que cualquier controlador personalizado debe implementar o sobrescribir en el archivo .cpp.</p> <p>Explicaremos cada uno de estos m\u00e9todos en un momento, cuando los implementemos en el c\u00f3digo.</p> <p><pre><code>protected:\n  std::vector&lt;std::string&gt; joint_names_;\n  std::string interface_name_;\n\n  // Command subscribers and Controller State publisher\n  using ControllerCommandMsg = control_msgs::msg::JointJog;\n\n  rclcpp::Subscription&lt;ControllerCommandMsg&gt;::SharedPtr command_subscriber_ =\n      nullptr;\n  realtime_tools::RealtimeBuffer&lt;std::shared_ptr&lt;ControllerCommandMsg&gt;&gt;\n      input_command_;\n\n  using ControllerStateMsg = control_msgs::msg::JointControllerState;\n  using ControllerStatePublisher =\n      realtime_tools::RealtimePublisher&lt;ControllerStateMsg&gt;;\n\n  rclcpp::Publisher&lt;ControllerStateMsg&gt;::SharedPtr s_publisher_;\n  std::unique_ptr&lt;ControllerStatePublisher&gt; state_publisher_;\n</code></pre> Finalmente, declaramos las variables que necesitaremos para este controlador, as\u00ed como un objeto suscriptor y un objeto publicador.</p>"},{"location":"controlador_propio/#definicion-del-archivo-fuente-del-controlador-cpp","title":"Definici\u00f3n del archivo fuente del controlador .cpp","text":"<p>A continuaci\u00f3n tenemos que agregar el archivo fuente correspondiente dentro de la carpeta src del paquete y definir todos los m\u00e9todos que acabamos de declarar en el archivo de encabezado.</p> <p>Dentro de la carpeta src , crear un archivo llamado rrbot_controller.cpp:</p> <pre><code>touch ~/ros2_ws/src/rrbot_controller/src/rrbot_controller.cpp\n</code></pre> <p>Luego agregar el siguiente fragmento de c\u00f3digo en ese archivo:</p> <pre><code>// Copyright (c) 2021, Bence Magyar and Denis Stogl\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"rrbot_controller/rrbot_controller.hpp\"\n\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace rrbot_controller\n{\nRRBotController::RRBotController() : controller_interface::ControllerInterface() {}\n\n// All the methods added must be inside this namespace\n\n}  // namespace rrbot_controller\n</code></pre> <p>Guardar el archivo. En los siguientes apartados se ir\u00e1n implementando las funciones necesarias dentro de este c\u00f3digo.</p>"},{"location":"controlador_propio/#explicacion-del-codigo_1","title":"Explicaci\u00f3n del c\u00f3digo","text":"<p>En primer lugar se definen las librer\u00edas necesarias y el espacio de nombres que encierra esta clase:</p> <pre><code>#include \"rrbot_controller/rrbot_controller.hpp\"\n\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n</code></pre> <p>Luego agregamos la definici\u00f3n del espacio de nombres que encierra la implementaci\u00f3n de los m\u00e9todos RRBotController de la clase:</p> <pre><code>namespace rrbot_controller\n{\nRRBotController::RRBotController() : controller_interface::ControllerInterface() {}\n\n// All the methods added must be inside this namespace\n\n}  // namespace rrbot_controller\n</code></pre> <p>Tener en cuenta que todos los m\u00e9todos que agregaremos a este archivo deben ubicarse dentro de este espacio de nombres. La \u00faltima llave de cierre indica el final del espacio de nombres.</p>"},{"location":"controlador_propio/#metodo-on_init","title":"M\u00e9todo on_init()","text":"<p>Durante la etapa de inicializaci\u00f3n, declaramos todos los par\u00e1metros que aceptaremos durante la vida \u00fatil del controlador. Esto se hace para que el tipo y el nombre del par\u00e1metro est\u00e9n bien definidos en el momento del inicio, lo que reduce las posibilidades de una configuraci\u00f3n incorrecta m\u00e1s adelante.</p> <p>Para continuar con el controlador de la secci\u00f3n anterior, copia y pega el c\u00f3digo que se muestra a continuaci\u00f3n en el archivo rrbot_controller.cpp. Aseg\u00farate de pegarlo dentro de los corchetes del espacio de nombres.</p> <pre><code>CallbackReturn RRBotController::on_init() {\n  try {\n    auto_declare(\"joints\", std::vector&lt;std::string&gt;());\n    auto_declare(\"interface_name\", std::string());\n  } catch (const std::exception &amp;e) {\n    fprintf(stderr, \"Exception thrown during init stage with message: %s \\n\",\n            e.what());\n    return CallbackReturn::ERROR;\n  }\n\n  return CallbackReturn::SUCCESS;\n}\n</code></pre> <p>Rodeamos el c\u00f3digo con un bloque try/catch para poder notificar al administrador del controlador si ocurre alg\u00fan problema al procesar el m\u00e9todo on_init(). En este ejemplo, on_init() ejecuta la declaraci\u00f3n de los par\u00e1metros que este controlador requerir\u00e1 y leer\u00e1 del archivo de configuraci\u00f3n del controlador. Si hay alg\u00fan error en este segmento de c\u00f3digo, este m\u00e9todo devolver\u00e1 un error y la m\u00e1quina de estados del administrador del controlador cambiar\u00e1 a \"finalizado\". Si todo sale bien, devolvemos CallbackReturn::SUCCESS.</p>"},{"location":"controlador_propio/#metodo-on_configure","title":"M\u00e9todo on_configure()","text":"<p>El m\u00e9todo on_configure() se utiliza para leer los valores de los par\u00e1metros y declarar los suscriptores y publicadores necesarios. Este m\u00e9todo se ejecuta antes de la llamada al m\u00e9todo update y garantiza que, una vez que el algoritmo de control entre en acci\u00f3n, todo est\u00e9 configurado y listo para funcionar.</p> <p>Este es el c\u00f3digo C++ que implmenta el template para on_configure(). A\u00f1adirlo al c\u00f3digo fuente del controlador: <pre><code>CallbackReturn RRBotController::on_configure(\n    const rclcpp_lifecycle::State &amp; /*previous_state*/) {\n  auto error_if_empty = [&amp;](const auto &amp;parameter, const char *parameter_name) {\n    if (parameter.empty()) {\n      RCLCPP_ERROR(get_node()-&gt;get_logger(), \"'%s' parameter was empty\",\n                   parameter_name);\n      return true;\n    }\n    return false;\n  };\n\n  auto get_string_array_param_and_error_if_empty =\n      [&amp;](std::vector&lt;std::string&gt; &amp;parameter, const char *parameter_name) {\n        parameter = get_node()-&gt;get_parameter(parameter_name).as_string_array();\n        return error_if_empty(parameter, parameter_name);\n      };\n\n  auto get_string_param_and_error_if_empty =\n  [&amp;](std::string &amp;parameter, const char *parameter_name) {\n    parameter = get_node()-&gt;get_parameter(parameter_name).as_string();\n    return error_if_empty(parameter, parameter_name);\n  };\n\n  if (\n    get_string_array_param_and_error_if_empty(joint_names_, \"joints\") ||\n      get_string_param_and_error_if_empty(interface_name_, \"interface_name\")) {\n    return CallbackReturn::ERROR;\n  }\n\n  // Command Subscriber and callbacks\n  auto callback_command =\n      [&amp;](const std::shared_ptr&lt;ControllerCommandMsg&gt; msg) -&gt; void {\n    if (msg-&gt;joint_names.size() == joint_names_.size()) {\n      input_command_.writeFromNonRT(msg);\n    } else {\n      RCLCPP_ERROR(get_node()-&gt;get_logger(),\n                   \"Received %zu , but expected %zu joints in command. \"\n                   \"Ignoring message.\",\n                   msg-&gt;joint_names.size(), joint_names_.size());\n    }\n  };\n  command_subscriber_ = get_node()-&gt;create_subscription&lt;ControllerCommandMsg&gt;(\n      \"~/commands\", rclcpp::SystemDefaultsQoS(), callback_command);\n\n  // State publisher\n  s_publisher_ =\n  get_node()-&gt;create_publisher&lt;ControllerStateMsg&gt;(\n      \"~/state\", rclcpp::SystemDefaultsQoS());\n  state_publisher_ = std::make_unique&lt;ControllerStatePublisher&gt;(s_publisher_);\n\n  state_publisher_-&gt;lock();\n  state_publisher_-&gt;msg_.header.frame_id = joint_names_[0];\n  state_publisher_-&gt;unlock();\n\n  RCLCPP_INFO_STREAM(get_node()-&gt;get_logger(), \"configure successful\");\n  return CallbackReturn::SUCCESS;\n}\n</code></pre></p>"},{"location":"controlador_propio/#explicacion-del-codigo_2","title":"Explicaci\u00f3n del c\u00f3digo","text":"<p><pre><code>  auto error_if_empty = [&amp;](const auto &amp; parameter, const char * parameter_name) {\n    if (parameter.empty()) {\n      RCLCPP_ERROR(get_node()-&gt;get_logger(), \"'%s' parameter was empty\", parameter_name);\n      return true;\n    }\n    return false;\n  };\n</code></pre> En la primera parte del m\u00e9todo on_configure(), declaramos una funci\u00f3n lambda para verificar si hay par\u00e1metros vac\u00edos y devolver un valor booleano. <pre><code>  auto get_string_array_param_and_error_if_empty =\n    [&amp;](std::vector&lt;std::string&gt; &amp; parameter, const char * parameter_name) {\n      parameter = get_node()-&gt;get_parameter(parameter_name).as_string_array();\n      return error_if_empty(parameter, parameter_name);\n    };\n</code></pre> A continuaci\u00f3n, declaramos una segunda funci\u00f3n lambda para recuperar una cadena de par\u00e1metros y verificar si el array de par\u00e1metros est\u00e1 vac\u00edo, utilizando la primera funci\u00f3n lambda declarada anteriormente. <pre><code>  auto get_string_param_and_error_if_empty =\n    [&amp;](std::string &amp; parameter, const char * parameter_name) {\n      parameter = get_node()-&gt;get_parameter(parameter_name).as_string();\n      return error_if_empty(parameter, parameter_name);\n    };\n</code></pre> Despu\u00e9s de eso, declaramos una tercera funci\u00f3n lambda para recuperar un par\u00e1metro de tipo cadena y realizar la verificaci\u00f3n de vac\u00edo, la cual tambi\u00e9n devuelve un valor booleano. <pre><code>  if (\n    get_string_array_param_and_error_if_empty(joint_names_, \"joints\") ||\n    get_string_param_and_error_if_empty(interface_name_, \"interface_name\")) {\n    return CallbackReturn::ERROR;\n  }\n</code></pre> En el c\u00f3digo anteriorse llama a la segunda y tercera funci\u00f3n lambda para evaluar si el array de par\u00e1metros \"joints\" y el par\u00e1metro \"interface\" est\u00e1n vac\u00edos, en cuyo caso el m\u00e9todo on_configure() devuelve CallbackReturn::ERROR. <pre><code>  // Command Subscriber and callbacks\n  auto callback_command = [&amp;](const std::shared_ptr&lt;ControllerCommandMsg&gt; msg) -&gt; void {\n    if (msg-&gt;joint_names.size() == joint_names_.size()) {\n      input_command_.writeFromNonRT(msg);\n    } else {\n      RCLCPP_ERROR(\n        get_node()-&gt;get_logger(),\n        \"Received %zu , but expected %zu joints in command. Ignoring message.\",\n        msg-&gt;joint_names.size(), joint_names_.size());\n    }\n  };\n  command_subscriber_ = get_node()-&gt;create_subscription&lt;ControllerCommandMsg&gt;(\n    \"~/commands\", rclcpp::SystemDefaultsQoS(), callback_command);\n</code></pre> En la segunda parte del on_configure() mostrada anteriormente, declaramos una funci\u00f3n lambda como la funci\u00f3n de devoluci\u00f3n de llamada para el comando y declaramos un objeto suscriptor de comandos. <pre><code>  // State publisher\n  s_publisher_ =\n    get_node()-&gt;create_publisher&lt;ControllerStateMsg&gt;(\"~/state\", rclcpp::SystemDefaultsQoS());\n  state_publisher_ = std::make_unique&lt;ControllerStatePublisher&gt;(s_publisher_);\n\n  state_publisher_-&gt;lock();\n  state_publisher_-&gt;msg_.header.frame_id = joint_names_[0];\n  state_publisher_-&gt;unlock();\n</code></pre> A continuaci\u00f3n, declaramos un publicador para transmitir los estados de las articulaciones y lo convertimos en un puntero \u00fanico. Las \u00faltimas tres l\u00edneas anteriores se utilizan para evitar que m\u00faltiples hilos accedan al mensaje publicado al mismo tiempo, mientras se establece el valor del frame_id en el encabezado. <pre><code>  RCLCPP_INFO_STREAM(get_node()-&gt;get_logger(), \"configure successful\");\n  return CallbackReturn::SUCCESS;\n</code></pre> Al finalizar, el m\u00e9todo on_configure() informa al usuario sobre su finalizaci\u00f3n exitosa y devuelve CallbackReturn::SUCCESS.</p>"},{"location":"controlador_propio/#metodo-command_interface_configuration","title":"M\u00e9todo command_interface_configuration()","text":"<p>En este m\u00e9todo se define las interfaces de comando necesarias.</p> <p>A\u00f1adir el siguiente bloque de c\u00f3digo al archivo rrbot_controller.cpp dentro del espacio de nombres:</p> <pre><code>controller_interface::InterfaceConfiguration RRBotController::command_interface_configuration()\n  const\n{\n  controller_interface::InterfaceConfiguration command_interfaces_config;\n  command_interfaces_config.type = controller_interface::interface_configuration_type::INDIVIDUAL;\n\n  command_interfaces_config.names.reserve(joint_names_.size());\n  for (const auto &amp; joint : joint_names_) {\n    command_interfaces_config.names.push_back(joint + \"/\" + interface_name_);\n  }\n\n  return command_interfaces_config;\n}\n</code></pre>"},{"location":"controlador_propio/#explicacion-del-codigo_3","title":"Explicaci\u00f3n del c\u00f3digo","text":"<pre><code>  controller_interface::InterfaceConfiguration command_interfaces_config;\n  command_interfaces_config.type = controller_interface::interface_configuration_type::INDIVIDUAL;\n</code></pre> <p>Primero se crea un nuevo objeto InterfaceConfiguration y se establece el tipo como INDIVIDUAL. Hay tres opciones para la configuraci\u00f3n de la interfaz: ALL, INDIVIDUAL y NONE. ALL y NONE solicitar\u00e1n acceso a todas las interfaces disponibles o a ninguna de ellas. La configuraci\u00f3n INDIVIDUAL necesita una lista detallada de los nombres de las interfaces requeridas. Normalmente, estos se proporcionan como par\u00e1metros. La llamada anterior reservar\u00e1 espacio de memoria para el vector de nombres de interfaces. <pre><code>  command_interfaces_config.names.reserve(joint_names_.size());\n  for (const auto &amp; joint : joint_names_) {\n    command_interfaces_config.names.push_back(joint + \"/\" + interface_name_);\n  }\n</code></pre> En el bloque anterior, la primera l\u00ednea reserva espacio de memoria para el vector de nombres de interfaces.</p> <p>Luego, a cada articulaci\u00f3n se le asigna su propio nombre de interfaz, que se guarda dentro de command_interfaces_config.names. Un nombre de interfaz completo debe tener la estructura /."},{"location":"controlador_propio/#metodo-state_interface_configuration","title":"M\u00e9todo state_interface_configuration()","text":"<p>Este m\u00e9todo cumple una funci\u00f3n similar a la del m\u00e9todo anterior, con la diferencia de que este se utiliza para definir qu\u00e9 interfaces de sensores de hardware son requeridas por el controlador.</p> <p>A\u00f1adir el siguiente c\u00f3digo a rrbot_controller.cpp:</p> <pre><code>controller_interface::InterfaceConfiguration RRBotController::state_interface_configuration() const\n{\n  controller_interface::InterfaceConfiguration state_interfaces_config;\n  state_interfaces_config.type = controller_interface::interface_configuration_type::INDIVIDUAL;\n\n  state_interfaces_config.names.reserve(joint_names_.size());\n  for (const auto &amp; joint : joint_names_) {\n    state_interfaces_config.names.push_back(joint + \"/\" + interface_name_);\n  }\n\n  return state_interfaces_config;\n}\n</code></pre>"},{"location":"controlador_propio/#explicacion-del-codigo_4","title":"Explicaci\u00f3n del c\u00f3digo","text":"<pre><code>  controller_interface::InterfaceConfiguration state_interfaces_config;\n  state_interfaces_config.type = controller_interface::interface_configuration_type::INDIVIDUAL;\n</code></pre> <p>De nuevo se crea un nuevo objeto InterfaceConfiguration y se establece el tipo como INDIVIDUAL. <pre><code>state_interfaces_config.names.reserve(joint_names_.size());\n</code></pre> Luego, reservamos memoria para el tama\u00f1o de la interfaz. <pre><code>  for (const auto &amp; joint : joint_names_) {\n    state_interfaces_config.names.push_back(joint + \"/\" + interface_name_);\n  }\n</code></pre></p> <p>Este es un procedimiento est\u00e1ndar para almacenar los nombres de las articulaciones desde archivos de configuraci\u00f3n .yaml, as\u00ed que este m\u00e9todo no cambiar\u00e1 mucho en otra implementaci\u00f3n personalizada de un controlador.</p>"},{"location":"controlador_propio/#metodo-template-get_ordered_interfaces","title":"M\u00e9todo template get_ordered_interfaces()","text":"<p>A continuaci\u00f3n agregar la funci\u00f3n template get_ordered_interfaces() que se muestra a continuaci\u00f3n al final del m\u00e9todo state_interface_configuration() que agregaste anteriormente. <pre><code>template &lt;typename T&gt;\nbool get_ordered_interfaces(\n  std::vector&lt;T&gt; &amp; unordered_interfaces, const std::vector&lt;std::string&gt; &amp; joint_names,\n  const std::string &amp; interface_type, std::vector&lt;std::reference_wrapper&lt;T&gt;&gt; &amp; ordered_interfaces)\n{\n  for (const auto &amp; joint_name : joint_names) {\n    for (auto &amp; command_interface : unordered_interfaces) {\n      if (\n        (command_interface.get_name() == joint_name) &amp;&amp;\n        (command_interface.get_interface_name() == interface_type)) {\n        ordered_interfaces.push_back(std::ref(command_interface));\n      }\n    }\n  }\n\n  return joint_names.size() == ordered_interfaces.size();\n}\n</code></pre> Esta funci\u00f3n template recibe como argumento un vector desordenado de interfaces y lo convierte en un vector ordenado. Es necesario incluir ordered_interfaces con referencias a las interfaces que coinciden, en el mismo orden que en joint_names.</p>"},{"location":"controlador_propio/#metodo-on_activate","title":"M\u00e9todo on_activate()","text":"<p>Se utiliza el m\u00e9todo on_activate() para declarar un mensaje de comando y establecer el valor predeterminado para el comando (copiar y pegar este c\u00f3digo como en casos anteriores).</p> <pre><code>CallbackReturn RRBotController::on_activate(const rclcpp_lifecycle::State &amp; /*previous_state*/)\n{\n  // Set default value in command\n  std::shared_ptr&lt;ControllerCommandMsg&gt; msg = std::make_shared&lt;ControllerCommandMsg&gt;();\n  msg-&gt;joint_names = joint_names_;\n  msg-&gt;displacements.resize(joint_names_.size(), std::numeric_limits&lt;double&gt;::quiet_NaN());\n  input_command_.writeFromNonRT(msg);\n\n  return CallbackReturn::SUCCESS;\n}\n</code></pre>"},{"location":"controlador_propio/#explicacion-del-codigo_5","title":"Explicaci\u00f3n del c\u00f3digo","text":"<p><pre><code>  // Set default value in command\n  std::shared_ptr&lt;ControllerCommandMsg&gt; msg = std::make_shared&lt;ControllerCommandMsg&gt;();\n  msg-&gt;joint_names = joint_names_;\n  msg-&gt;displacements.resize(joint_names_.size(), std::numeric_limits&lt;double&gt;::quiet_NaN());\n</code></pre> Arriba declaramos un mensaje utilizando el tipo de dato ControllerCommandMsg, se completa el campo joint_names en el mensaje y se establece el valor predeterminado en el comando al valor especial \"quiet not-a-number\", que tiene un significado espec\u00edfico para los tipos de punto flotante. <pre><code>  input_command_.writeFromNonRT(msg);\n</code></pre> Aqu\u00ed se usa writeFromNonRT, que se puede utilizar en tiempo real (RT), si tenemos la garant\u00eda de que:</p> <ul> <li>Ning\u00fan hilo no-RT est\u00e1 llamando a la misma funci\u00f3n (no estamos suscribi\u00e9ndonos a callbacks de ROS).</li> <li>Solo hay un \u00fanico hilo RT.</li> </ul>"},{"location":"controlador_propio/#metodo-on_deactivate","title":"M\u00e9todo on_deactivate()","text":"<p>Copiar y pegar el sigiente c\u00f3digo que implementa el m\u00e9todo on_deactivate: <pre><code>CallbackReturn RRBotController::on_deactivate(const rclcpp_lifecycle::State &amp; /*previous_state*/)\n{\n  return CallbackReturn::SUCCESS;\n}\n</code></pre> Lo \u00fanico que se se hace aqu\u00ed es devolver CallbackReturn::SUCCESS cuando se llame al m\u00e9todo.</p>"},{"location":"controlador_propio/#metodo-update","title":"M\u00e9todo update()","text":"<p>La funci\u00f3n update() se llama en el bucle de control para generar un comando de control para el hardware. Para implementar el m\u00e9todo update(), pega el siguiente c\u00f3digo al final del archivo pero dentro del espacio de nombres: <pre><code>controller_interface::return_type\nRRBotController::update(const rclcpp::Time &amp;time,\n                        const rclcpp::Duration &amp; /*period*/) {\n  auto current_command = input_command_.readFromRT();\n\n  for (size_t i = 0; i &lt; command_interfaces_.size(); ++i) {\n    if (!std::isnan((*current_command)-&gt;displacements[i])) {\n        if (!command_interfaces_[i].set_value((*current_command)-&gt;displacements[i])){\n            RCLCPP_ERROR(\n                get_node()-&gt;get_logger(), \n                \"Failed to set command interface value for joint %zu\", \n                i\n            );\n            return controller_interface::return_type::ERROR;\n        }\n    }\n  }\n\n  if (state_publisher_ &amp;&amp; state_publisher_-&gt;trylock()) {\n    state_publisher_-&gt;msg_.header.stamp = time;\n    state_publisher_-&gt;msg_.set_point = command_interfaces_[0].get_value();\n\n    state_publisher_-&gt;unlockAndPublish();\n  }\n\n  return controller_interface::return_type::OK;\n}\n</code></pre></p>"},{"location":"controlador_propio/#explicacion-del-codigo_6","title":"Explicaci\u00f3n del c\u00f3digo","text":"<p><pre><code>auto current_command = input_command_.readFromRT();\n</code></pre> Aqu\u00ed se obtiene un puntero de datos con readFromRT() <pre><code>  for (size_t i = 0; i &lt; command_interfaces_.size(); ++i) {\n    if (!std::isnan((*current_command)-&gt;displacements[i])) {\n        if (!command_interfaces_[i].set_value((*current_command)-&gt;displacements[i])){\n            RCLCPP_ERROR(\n                get_node()-&gt;get_logger(), \n                \"Failed to set command interface value for joint %zu\", \n                i\n            );\n            return controller_interface::return_type::ERROR;\n        }\n    }\n  }\n</code></pre> Para cada articulaci\u00f3n, se establece como valor de la acci\u00f3n de control los datos no modificados que est\u00e1n dentro del vector de desplazamientos. <pre><code>  if (state_publisher_ &amp;&amp; state_publisher_-&gt;trylock()) {\n    state_publisher_-&gt;msg_.header.stamp = get_node()-&gt;now();\n    state_publisher_-&gt;msg_.set_point = command_interfaces_[0].get_value();\n\n    state_publisher_-&gt;unlockAndPublish();\n  }\n</code></pre> Este ejemplo est\u00e1 implementando un controlador Forward command controller para un conjunto de articulaciones. B\u00e1sicamente, reenv\u00eda como se\u00f1al de control el valor pasado como consigna.</p>"},{"location":"controlador_propio/#macro-pluginlib_export_class","title":"macro PLUGINLIB_EXPORT_CLASS","text":"<p>Despu\u00e9s de cerrar el espacio de nombres, hay que a\u00f1adir una llamada a la macro PLUGINLIB_EXPORT_CLASS al final del archivo .cpp. Agregar el siguiente bloque de c\u00f3digo al final de tu archivo de c\u00f3digo fuente, despu\u00e9s de que se cierre el espacio de nombres: <pre><code>#include \"pluginlib/class_list_macros.hpp\"\n\nPLUGINLIB_EXPORT_CLASS(rrbot_controller::RRBotController, controller_interface::ControllerInterface)\n</code></pre> Esta macro sirve para registrar este controlador dentro del sistema de plugins de ROS2.</p>"},{"location":"controlador_propio/#escribir-un-fichero-de-descripcion-del-plugin","title":"Escribir un fichero de descripci\u00f3n del plugin","text":"<p>El siguiente paso es escribir un archivo de definici\u00f3n de exportaci\u00f3n para Pluginlib, tal como se hace cuando se crea cualquier otro plugin de Pluginlib. Crear un nuevo archivo llamado rrbot_controller.xml en el directorio ra\u00edz del paquete donde se encuentra el archivo CMakeLists.txt: <pre><code>touch ~/ros2_ws/src/rrbot_controller/rrbot_controller.xml\n</code></pre> Este ser\u00e1 el contenido del xml: <pre><code>&lt;library path=\"rrbot_controller\"&gt;\n  &lt;class name=\"rrbot_controller/RRBotController\"\n         type=\"rrbot_controller::RRBotController\" base_class_type=\"controller_interface::ControllerInterface\"&gt;\n  &lt;description&gt;\n    RRBotController ros2_control controller.\n  &lt;/description&gt;\n  &lt;/class&gt;\n&lt;/library&gt;\n</code></pre> Guardar el contenido y seguir con el siguiente paso.</p>"},{"location":"controlador_propio/#explicacion-del-codigo_7","title":"Explicaci\u00f3n del c\u00f3digo","text":"<p>El elemento  especifica la ruta relativa a la biblioteca que contiene el complemento que se desea exportar. En este caso, es rrbot_controller. <p>La etiqueta  declara el complemento que se quiere exportar. Los par\u00e1metros son los siguientes: <ul> <li>name: nombre del complemento de ROS2_control.</li> <li>type: espacio de nombres y el nombre de la clase que implementa el complemento.</li> <li>base_class_type: espacio de nombres y nombre de la clase base de la que hereda este complemento. La etiqueta anidada  encierra una descripci\u00f3n del complemento y su funcionalidad. <p>Nota: El archivo XML del complemento debe declarar todos los complementos contenidos en un paquete. En este caso, solo hay uno.</p>"},{"location":"controlador_propio/#preparar-los-ficheros-cmakeliststxt-y-packagexml","title":"Preparar los ficheros CMakeLists.txt y package.xml","text":""},{"location":"controlador_propio/#anadir-las-directivas-de-compilacion-necesarias-en-el-archivo-cmakeliststxt","title":"A\u00f1adir las directivas de compilaci\u00f3n necesarias en el archivo CMakeLists.txt","text":"<p>Este paso agrega las directivas de compilaci\u00f3n necesarias en CMakeLists.txt, que son requeridas para compilar el paquete.</p> <p>El archivo CMakeLists.txt final deber\u00eda ser el siguiente: <pre><code>cmake_minimum_required(VERSION 3.5)\nproject(rrbot_controller)\n\n# Default to C++14\nif(NOT CMAKE_CXX_STANDARD)\n  set(CMAKE_CXX_STANDARD 14)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\n# find dependencies\nfind_package(ament_cmake REQUIRED)\nfind_package(control_msgs REQUIRED)\nfind_package(controller_interface REQUIRED)\nfind_package(hardware_interface REQUIRED)\nfind_package(pluginlib REQUIRED)\nfind_package(rclcpp REQUIRED)\nfind_package(rclcpp_lifecycle REQUIRED)\nfind_package(realtime_tools REQUIRED)\nfind_package(example_interfaces REQUIRED)\n\nadd_library(\n  rrbot_controller\n  SHARED\n  src/rrbot_controller.cpp\n)\ntarget_include_directories(\n  rrbot_controller\n  PUBLIC\n  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;\n  $&lt;INSTALL_INTERFACE:include&gt;\n)\nament_target_dependencies(\n  rrbot_controller\n  control_msgs\n  controller_interface\n  hardware_interface\n  pluginlib\n  rclcpp\n  rclcpp_lifecycle\n  realtime_tools\n)\n# prevent pluginlib from using boost\ntarget_compile_definitions(rrbot_controller PUBLIC \"PLUGINLIB__DISABLE_BOOST_FUNCTIONS\")\n\npluginlib_export_plugin_description_file(\n  controller_interface rrbot_controller.xml)\n\ninstall(\n  TARGETS\n  rrbot_controller\n  RUNTIME DESTINATION bin\n  ARCHIVE DESTINATION lib\n  LIBRARY DESTINATION lib\n)\n\ninstall(\n  DIRECTORY include/\n  DESTINATION include\n)\n\nament_export_include_directories(\n  include\n)\nament_export_libraries(\n  rrbot_controller\n)\nament_export_dependencies(\n  control_msgs\n  controller_interface\n  hardware_interface\n  pluginlib\n  rclcpp\n  rclcpp_lifecycle\n  realtime_tools\n)\n\nament_package()\n</code></pre></p>"},{"location":"controlador_propio/#explicacion-del-codigo_8","title":"Explicaci\u00f3n del c\u00f3digo","text":"<p><pre><code>add_library(\n  rrbot_controller\n  SHARED\n  src/rrbot_controller.cpp\n)\n\ntarget_include_directories(\n  rrbot_controller\n  PUBLIC\n  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;\n  $&lt;INSTALL_INTERFACE:include&gt;\n)\n\nament_target_dependencies(\n  rrbot_controller\n  control_msgs\n  controller_interface\n  hardware_interface\n  pluginlib\n  rclcpp\n  rclcpp_lifecycle\n  realtime_tools\n)\n</code></pre> Aqu\u00ed se agrega los archivos fuente al comando add_library() de CMake. Tambi\u00e9n, hay que tener en cuenta el uso de expresiones generadoras con la sintaxis $&lt;.. : ..&gt; como argumentos para la directiva target_include_directories. <pre><code>target_compile_definitions(rrbot_controller PUBLIC \"PLUGINLIB__DISABLE_BOOST_FUNCTIONS\")\n</code></pre> Esta l\u00ednea evita que pluginlib use Boost. <pre><code>pluginlib_export_plugin_description_file(controller_interface rrbot_controller.xml)\n</code></pre> El comando de CMake anterior instalar\u00e1 el archivo de descripci\u00f3n del complemento (rrbot_controller.xml) para que pluginlib pueda cargar el complemento.</p> <p>Los argumentos de este comando son:</p> <ul> <li>El paquete de la clase base, es decir, controller_interface.</li> <li>La ruta relativa al archivo XML de declaraci\u00f3n del complemento, en este caso, solo el nombre del archivo: rrbot_controller.xml. <pre><code>install(\n  TARGETS\n  rrbot_controller\n  RUNTIME DESTINATION bin\n  ARCHIVE DESTINATION lib\n  LIBRARY DESTINATION lib\n)\n\ninstall(\n  DIRECTORY include/\n  DESTINATION include\n)\n</code></pre> Esto copiar\u00e1 los binarios generados en lib e include. Tambi\u00e9n indicamos a CMake que instale todos los archivos de lanzamiento dentro de la carpeta launch. <pre><code>ament_export_include_directories(\n  include\n)\nament_export_libraries(\n  rrbot_controller\n)\nament_export_dependencies(\n  control_msgs\n  controller_interface\n  hardware_interface\n  pluginlib\n  rclcpp\n  rclcpp_lifecycle\n  realtime_tools\n)\n</code></pre> Las l\u00edneas anteriores exportan el directorio de inclusi\u00f3n, la biblioteca y las dependencias para que otros proyectos las utilicen.</li> </ul>"},{"location":"controlador_propio/#anadir-las-dependencias-en-el-paquete-packagexml","title":"A\u00f1adir las dependencias en el paquete package.xml","text":"<p>Normalmente, se necesita agregar las dependencias externas al archivo package.xml para que ament pueda compilar el paquete.</p> <p>Deja este archivo sin modificar, ya que en este controlador personalizado no se utiliza ninguna biblioteca externa. <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n&lt;package format=\"3\"&gt;\n  &lt;name&gt;rrbot_controller&lt;/name&gt;\n  &lt;version&gt;0.0.0&lt;/version&gt;\n\n  &lt;description&gt;Controller for exemplary RRBot robot.&lt;/description&gt;\n\n  &lt;maintainer email=\"bence.magyar.robotics@gmail.com\"&gt;Bence Magyar&lt;/maintainer&gt;\n  &lt;maintainer email=\"denis@stogl.de\"&gt;Denis \u0160togl&lt;/maintainer&gt;\n\n  &lt;license&gt;Apache License 2.0&lt;/license&gt;\n\n  &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;\n\n  &lt;depend&gt;control_msgs&lt;/depend&gt;\n  &lt;depend&gt;controller_interface&lt;/depend&gt;\n  &lt;depend&gt;hardware_interface&lt;/depend&gt;\n  &lt;depend&gt;pluginlib&lt;/depend&gt;\n  &lt;depend&gt;rclcpp&lt;/depend&gt;\n  &lt;depend&gt;rclcpp_lifecycle&lt;/depend&gt;\n  &lt;depend&gt;realtime_tools&lt;/depend&gt;\n  &lt;depend&gt;example_interfaces&lt;/depend&gt;\n\n  &lt;test_depend&gt;ament_cmake_gmock&lt;/test_depend&gt;\n  &lt;test_depend&gt;controller_manager&lt;/test_depend&gt;\n  &lt;test_depend&gt;hardware_interface&lt;/test_depend&gt;\n  &lt;test_depend&gt;ros2_control_test_assets&lt;/test_depend&gt;\n\n  &lt;export&gt;\n    &lt;build_type&gt;ament_cmake&lt;/build_type&gt;\n  &lt;/export&gt;\n&lt;/package&gt;\n</code></pre> Ahora se deber\u00eda compilar y corregir cualquier error que pueda aparecer: <pre><code>cd ~/ros2_ws &amp;&amp; colcon build --packages-select rrbot_controller\n</code></pre></p>"},{"location":"controlador_propio/#crear-un-fichero-de-configuracion-del-controlador-para-el-controller-manager-yaml","title":"Crear un fichero de configuraci\u00f3n del controlador para el Controller Manager (.yaml)","text":"<p>Ahora se van a crear los archivos de configuraci\u00f3n para ros2_control y el controlador que se utilizar\u00e1. El archivo de configuraci\u00f3n estar\u00e1 dentro de la carpeta config, del paquete my_robot_bringup creado anteriormente en la pr\u00e1ctica. <pre><code>touch ~/ros2_ws/src/my_robot_bringup/config/rrbot_controllers_custom.yaml\n</code></pre> Copiar el siguiente c\u00f3digo en el fichero rrbot_controllers_custom.yaml: <pre><code># Controller manager configuration\ncontroller_manager:\n  ros__parameters:\n    update_rate: 50  # Hz\n\n    # Define a name for controllers that we plan to use\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    rrbot_controller:\n      type: rrbot_controller/RRBotController\n\n# Properties of the custom controler and definition of joints to use\nrrbot_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n    interface_name: position\n</code></pre> En este archivo de configuraci\u00f3n se establece que se utilizar\u00e1 el nuevo controlador para las dos articulaciones del robot. </p>"},{"location":"controlador_propio/#actualizar-los-parametros-de-configuracion-del-plugin-de-gazebo","title":"Actualizar los par\u00e1metros de configuraci\u00f3n del plugin de Gazebo","text":"<p>Ahora se necesita cargar el nuevo archivo de configuraci\u00f3n YAML. Al trabajar con Gazebo, se debe referenciar este archivo dentro de los par\u00e1metros de configuraci\u00f3n del plugin de Gazebo. Para ello, abrir el archivo XACRO del robot (rrbot.gazebo.xacro). En concreto, el archivo deber\u00eda encontrarse aqu\u00ed: ~/ros2_ws/src/ros2_robot_sca/description/gazebo.</p> <p>Localizar los tags del plugin de Gazebo ros2_control y modificar el elemento correspondiente para usar el nuevo fichero de configuraci\u00f3n rrbot_controllers_custom.yaml, en lugar del que se est\u00e1 usando actualmente.</p> <p>Esto es lo que debe aparecer en el nuevo plugin de configuraci\u00f3n de Gazebo ros2_control:</p> <pre><code>&lt;!-- ros_control plugin --&gt;\n&lt;gazebo&gt;\n  &lt;plugin filename=\"gz_ros2_control-system\" name=\"gz_ros2_control::GazeboSimROS2ControlPlugin\"&gt;\n    &lt;parameters&gt;$(find my_robot_bringup)/config/rrbot_controllers_custom.yaml&lt;/parameters&gt;\n  &lt;/plugin&gt;\n&lt;/gazebo&gt;\n</code></pre>"},{"location":"controlador_propio/#crear-un-nuevo-archivo-de-lanzamiento-para-generar-el-robot-y-ejecutar-el-nuevo-controlador","title":"Crear un nuevo archivo de lanzamiento para generar el robot y ejecutar el nuevo controlador","text":"<p>Crear un nuevo archivo de lanzamiento es opcional, ya que es posible iniciar y detener controladores \u00fanicamente utilizando la interfaz de l\u00ednea de comandos del controller manager. Sin embargo, es m\u00e1s c\u00f3modo crear un nuevo archivo de lanzamiento que genere el robot en Gazebo y ejecute el nuevo controlador. Este nuevo fichero de lanzamiento se crear\u00e1 en la carpeta launch del paquete my_robot_bringup creado en la pr\u00e1ctica: <pre><code>touch ~/ros2_ws/src/my_robot_bringup/launch/rrbot_with_rrbot_controller.launch.py\n</code></pre> El contenido de este fichero de lanzamiento ser\u00e1 el siguiente: <pre><code>from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.conditions import IfCondition\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import Command, FindExecutable, PathJoinSubstitution, LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\n\ndef generate_launch_description():\n\n    # Declare arguments\n    declared_arguments = []\n    declared_arguments.append(\n        DeclareLaunchArgument(\n            \"gui\",\n            default_value=\"false\",\n            description=\"Start RViz2 automatically with this launch file.\",\n        )\n    )\n\n    # Initialize Arguments\n    gui = LaunchConfiguration(\"gui\")\n\n    # gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            [FindPackageShare(\"ros_gz_sim\"), \"/launch/gz_sim.launch.py\"]\n        ),\n        launch_arguments={\"gz_args\": \" -r -v 3 empty.sdf\"}.items(),\n    )\n\n    gz_spawn_entity = Node(\n        package=\"ros_gz_sim\",\n        executable=\"create\",\n        output=\"screen\",\n        arguments=[\n            \"-topic\",\n            \"/robot_description\",\n            \"-name\",\n            \"rrbot_system_position\",\n            \"-allow_renaming\",\n            \"true\",\n        ],\n    )\n\n    # Get URDF via xacro\n    robot_description_content = Command(\n        [\n            PathJoinSubstitution([FindExecutable(name=\"xacro\")]),\n            \" \",\n            PathJoinSubstitution(\n                [FindPackageShare(\"ros2_robot_sca\"), \"urdf\", \"rrbot.urdf.xacro\"]\n            ),\n            \" \",\n            \"use_gazebo:=true\",\n        ]\n    )\n    robot_description = {\"robot_description\": robot_description_content}\n\n    robot_controllers = PathJoinSubstitution(\n        [\n            FindPackageShare(\"my_robot_bringup\"),\n            \"config\",\n            \"rrbot_controllers_custom.yaml\",\n        ]\n    )\n\n    rviz_config_file = PathJoinSubstitution(\n        [FindPackageShare(\"ros2_robot_sca\"), \"rrbot/rviz\", \"rrbot.rviz\"]\n    )\n\n    node_robot_state_publisher = Node(\n        package=\"robot_state_publisher\",\n        executable=\"robot_state_publisher\",\n        output=\"screen\",\n        parameters=[robot_description],\n    )\n\n    joint_state_broadcaster_spawner = Node(\n        package=\"controller_manager\",\n        executable=\"spawner\",\n        arguments=[\"joint_state_broadcaster\"],\n    )\n\n    robot_controller_spawner = Node(\n        package=\"controller_manager\",\n        executable=\"spawner\",\n        arguments=[\"rrbot_controller\", \"--param-file\", robot_controllers],\n    )\n\n    rviz_node = Node(\n        package=\"rviz2\",\n        executable=\"rviz2\",\n        name=\"rviz2\",\n        output=\"log\",\n        arguments=[\"-d\", rviz_config_file],\n        condition=IfCondition(gui),\n    )\n\n    nodes = [\n        gazebo,\n        node_robot_state_publisher,\n        gz_spawn_entity,\n        joint_state_broadcaster_spawner,\n        robot_controller_spawner,\n        rviz_node,\n    ]\n\n    return LaunchDescription(declared_arguments + nodes)\n</code></pre></p> <p>El fichero launch es parecido al creado anteriormente en la pr\u00e1ctica, la \u00fanica diferencia es este c\u00f3digo: <pre><code>robot_controller_spawner = Node(\n    package=\"controller_manager\",\n    executable=\"spawner\",\n    arguments=[\"rrbot_controller\", \"--param-file\", robot_controllers],\n)\n</code></pre> La diferencia es que el archivo de lanzamiento iniciar\u00e1 un controlador con el nombre rrbot_controller.</p>"},{"location":"controlador_propio/#recompilar-y-probar-el-nuevo-controlador","title":"Recompilar y probar el nuevo controlador","text":"<p>Ahora se debe recompilar y ejecutar source antes de continuar y probar el controlador en el robot. Es necesario recompilar para que el nuevo archivo de lanzamiento y el archivo de configuraci\u00f3n se copien en el espacio de instalaci\u00f3n. <pre><code>cd ~/ros2_ws\n</code></pre></p> <pre><code>colcon build\n</code></pre> <p>Si seguiste los pasos uno a uno hasta aqu\u00ed, ver\u00e1s que el c\u00f3digo se compila correctamente. <pre><code>source install/setup.bash\n</code></pre></p> <p>Ejecuta el nuevo archivo de lanzamiento que genera el robot y inicia el nuevo controlador: <pre><code>ros2 launch my_robot_bringup rrbot_with_rrbot_controller.launch.py\n</code></pre> En otra terminar confirmar que el nuevo controlador est\u00e1 activo (debe aparece el controlador rrbot_controller): <pre><code>ros2 control list_controllers\n</code></pre> En ocasiones es posible que en ROS 2 Jazzy, cuando creas un nuevo controlador como plugin para ros2_control, el sistema no lo detecte autom\u00e1ticamente hasta que reinicies el ordenador o m\u00e1quina virtual. Este comportamiento ocurre porque ros2_control carga los plugins disponibles al iniciar el sistema, y no siempre detecta din\u00e1micamente los nuevos plugins que se a\u00f1aden despu\u00e9s. </p> <p>A continuaci\u00f3n probar a mover las articulaciones del robot utilizando el nuevo controlador: <pre><code>ros2 topic pub /rrbot_controller/commands control_msgs/msg/JointJog \"{joint_names: ['joint_1', 'joint_2'], displacements: [0.5, 0.3]}\"\n</code></pre></p>"},{"location":"controlador_propio/#implementacion-de-un-controlador-pd-con-compensacion-de-gravedad","title":"Implementaci\u00f3n de un controlador PD con compensaci\u00f3n de gravedad","text":"<p>En este apartado se va a modificar el controlador desarrollado en el apartado anterior para implementar un controlador PD con compensaci\u00f3n de gravedad. La acci\u00f3n de control de un controlador PD con compensaci\u00f3n de gravedad es la siguiente:</p> \\[ \\tau= K_{p}\\tilde{q}+K_{v}\\dot{\\tilde{q}}+q(q) \\] <p>donde \\(K_{p}\\) y \\(K_{p}\\) son matrices diagonales porporcional y derivativa respectivamente de tama\u00f1o nxn siendo n el n\u00famero de grados de libertad del robot, \\(\\tilde{q}=q_d-q(t)\\) es el error entre la configuraci\u00f3n articular a alcanzar y la posici\u00f3n articular actual, y \\(g(q)\\) es la componente de gravedad del modelo dina\u1e3fico del robot evaluada en la posici\u00f3n actual.</p> <p>Para implementarlo se pueden seguir los pasos que se indican en los siguientes p\u00e1rrafos. Primero ser\u00e1 necesario incluir la libreria Pinocchio en el fichero rrbot_controller.cpp. Esta librer\u00eda se utilizar\u00e1 para acceder al vector de gravedad del modelo din\u00e1mico del robot:</p> <pre><code>#include &lt;pinocchio/parsers/urdf.hpp&gt;\n#include &lt;pinocchio/algorithm/joint-configuration.hpp&gt;\n#include &lt;pinocchio/algorithm/rnea.hpp&gt;\n</code></pre> <p>A continuaci\u00f3n, modificar la funcion on_init para leer los par\u00e1metros de los que depende el controlador PD con compensaci\u00f3n de gravedad (ganancias proporcional y derivativa): <pre><code>CallbackReturn RRBotController::on_init() {\n    try {\n      auto_declare(\"joints\", std::vector&lt;std::string&gt;());\n      auto_declare(\"interface_name\", std::string());\n\n      // Par\u00e1metros para el controlador PD con compensaci\u00f3n de gravedad\n      auto_declare(\"kp\", std::vector&lt;double&gt;());\n      auto_declare(\"kd\", std::vector&lt;double&gt;());\n\n      // Par\u00e1metro para la ruta del archivo URDF\n      auto_declare(\"robot_description_path\", std::string());\n    } catch (const std::exception &amp;e) {\n      fprintf(stderr, \"Exception thrown during init stage with message: %s \\n\",\n              e.what());\n      return CallbackReturn::ERROR;\n    }\n\n    return CallbackReturn::SUCCESS;\n  }\n</code></pre></p> <p>A continuaci\u00f3n, introducir el siguiente c\u00f3digo en On_configure justo despu\u00e9s de obtener joints y el interface_name y antes de crear el Command Subscriber and callbacks. Esto nos va a permitir crear el modelo de pinocchio: <pre><code>  // Obtener ganancias Kp y Kd\n  kp_ = get_node()-&gt;get_parameter(\"kp\").as_double_array();\n  kd_ = get_node()-&gt;get_parameter(\"kd\").as_double_array();\n\n  // Verificar que tenemos el n\u00famero correcto de ganancias\n  if (kp_.size() != joint_names_.size() || kd_.size() != joint_names_.size()) {\n    RCLCPP_ERROR(get_node()-&gt;get_logger(), \n                \"Se esperaban %zu ganancias, pero se recibieron %zu Kp y %zu Kd\",\n                joint_names_.size(), kp_.size(), kd_.size());\n    return CallbackReturn::ERROR;\n  }\n\n  // Obtener la ruta del archivo URDF\n  std::string urdf_path;\n  get_string_param_and_error_if_empty(urdf_path, \"robot_description_path\");\n\n  // Inicializar el modelo de Pinocchio desde el URDF\n  try {\n    // Crear el modelo y los datos\n    model_ = std::make_shared&lt;pinocchio::Model&gt;();\n\n    // Cargar el modelo desde el URDF\n    pinocchio::urdf::buildModel(urdf_path, *model_);\n    data_ = std::make_shared&lt;pinocchio::Data&gt;(*model_);\n\n    // Verificar que los nombres de las articulaciones coinciden\n    bool joints_found = true;\n    joint_indices_.resize(joint_names_.size());\n\n    for (size_t i = 0; i &lt; joint_names_.size(); ++i) {\n      if (model_-&gt;existJointName(joint_names_[i])) {\n        joint_indices_[i] = model_-&gt;getJointId(joint_names_[i]);\n      } else {\n        joints_found = false;\n        RCLCPP_ERROR(get_node()-&gt;get_logger(), \n                    \"No se encontr\u00f3 la articulaci\u00f3n '%s' en el modelo URDF\",\n                    joint_names_[i].c_str());\n      }\n    }\n\n    if (!joints_found) {\n      return CallbackReturn::ERROR;\n    }\n\n    RCLCPP_INFO(get_node()-&gt;get_logger(), \"Modelo Pinocchio inicializado con \u00e9xito\");\n  } catch (const std::exception&amp; e) {\n    RCLCPP_ERROR(get_node()-&gt;get_logger(), \n                \"Error al inicializar el modelo Pinocchio: %s\", \n                e.what());\n    return CallbackReturn::ERROR;\n  }\n</code></pre></p> <p>En controller_interface::InterfaceConfiguration RRBotController::command_interface_configuration() cambiar el interfaz para controlar por torque:</p> <pre><code>command_interfaces_config.names.push_back(joint + \"/effort\");  // Cambiado a effort para control de torque\n</code></pre> <p>En controller_interface::InterfaceConfiguration RRBotController::state_interface_configuration cambiarla por la siguiente funci\u00f3n ya que necesitamos leer tanto la posici\u00f3n como la velocidad articular para implementar el control PD:</p> <pre><code>controller_interface::InterfaceConfiguration RRBotController::state_interface_configuration() const\n{\n  controller_interface::InterfaceConfiguration state_interfaces_config;\n  state_interfaces_config.type = controller_interface::interface_configuration_type::INDIVIDUAL;\n\n  // Necesitamos leer tanto la posici\u00f3n como la velocidad para el control PD\n  state_interfaces_config.names.reserve(joint_names_.size() * 2);\n  for (const auto &amp; joint : joint_names_) {\n    state_interfaces_config.names.push_back(joint + \"/position\");\n    state_interfaces_config.names.push_back(joint + \"/velocity\");\n  }\n\n  return state_interfaces_config;\n}\n</code></pre> <p>Antes de get_ordered interfaces crear esta funci\u00f3n para calcular el vector de gravedad usando Pinocchio: <pre><code>std::vector&lt;double&gt; RRBotController::calculate_gravity_vector(const std::vector&lt;double&gt;&amp; q)\n{\n  // Crear un vector de configuraci\u00f3n para Pinocchio (podr\u00eda incluir articulaciones base flotante)\n  Eigen::VectorXd q_pin = Eigen::VectorXd::Zero(model_-&gt;nq);\n\n  // Llenar el vector de configuraci\u00f3n con los valores de las articulaciones controladas\n  for (size_t i = 0; i &lt; joint_names_.size(); ++i) {\n    // Ajustar el \u00edndice seg\u00fan c\u00f3mo est\u00e9 estructurado tu modelo en Pinocchio\n    q_pin[i] = q[i];\n  }\n\n  // Velocidades y aceleraciones cero para calcular solo la gravedad\n  Eigen::VectorXd v_pin = Eigen::VectorXd::Zero(model_-&gt;nv);\n  Eigen::VectorXd a_pin = Eigen::VectorXd::Zero(model_-&gt;nv);\n\n  // Calcular la din\u00e1mica inversa con velocidades y aceleraciones cero para obtener solo el vector de gravedad\n  pinocchio::rnea(*model_, *data_, q_pin, v_pin, a_pin);\n\n  // Extraer el torque de gravedad para nuestras articulaciones\n  std::vector&lt;double&gt; g_vector(joint_names_.size(), 0.0);\n  for (size_t i = 0; i &lt; joint_names_.size(); ++i) {\n    g_vector[i] = data_-&gt;tau[model_-&gt;joints[joint_indices_[i]].idx_v()];\n  }\n\n  return g_vector;\n}\n</code></pre></p> <p>En On_activate incorporar el siguiente c\u00f3digo que permitir\u00e1 leer posici\u00f3n y velocidad articular actual: <pre><code>// Obtener las interfaces de estado ordenadas (posici\u00f3n y velocidad)\n  position_state_interfaces_.clear();\n  velocity_state_interfaces_.clear();\n\n  for (size_t i = 0; i &lt; joint_names_.size(); ++i) {\n    // Buscar las interfaces de posici\u00f3n\n    for (auto&amp; interface : state_interfaces_) {\n      if (interface.get_name() == (joint_names_[i]+\"/\"+interface.get_interface_name()) &amp;&amp; \n          interface.get_interface_name() == \"position\") {\n        position_state_interfaces_.push_back(std::ref(interface));\n        break;\n      }\n    }\n\n    // Buscar las interfaces de velocidad\n    for (auto&amp; interface : state_interfaces_) {\n      if (interface.get_name() == (joint_names_[i]+\"/\"+interface.get_interface_name()) &amp;&amp; \n          interface.get_interface_name() == \"velocity\") {\n        velocity_state_interfaces_.push_back(std::ref(interface));\n        break;\n      }\n    }\n  }\n\n  // Verificar que tenemos todas las interfaces necesarias\n  if (position_state_interfaces_.size() != joint_names_.size() ||\n      velocity_state_interfaces_.size() != joint_names_.size()) {\n    RCLCPP_ERROR(get_node()-&gt;get_logger(), \n                \"No se pudieron encontrar todas las interfaces de estado necesarias\");\n    return CallbackReturn::ERROR;\n  }\n</code></pre></p> <p>La nueva funci\u00f3n update que calcula la acci\u00f3n de control ser\u00e1 la siguiente: <pre><code>controller_interface::return_type\nRRBotController::update(const rclcpp::Time &amp;time,\n                        const rclcpp::Duration &amp;period) {\n  auto current_command = input_command_.readFromRT();\n\n  // Obtener las posiciones y velocidades actuales\n  std::vector&lt;double&gt; current_positions(joint_names_.size(), 0.0);\n  std::vector&lt;double&gt; current_velocities(joint_names_.size(), 0.0);\n\n  for (size_t i = 0; i &lt; joint_names_.size(); ++i) {\n    current_positions[i] = position_state_interfaces_[i].get().get_value();\n    current_velocities[i] = velocity_state_interfaces_[i].get().get_value();\n  }\n\n  // Obtener posiciones deseadas del comando\n  std::vector&lt;double&gt; desired_positions(joint_names_.size(), 0.0);\n  for (size_t i = 0; i &lt; joint_names_.size(); ++i) {\n    if (!std::isnan((*current_command)-&gt;displacements[i])) {\n      desired_positions[i] = (*current_command)-&gt;displacements[i];\n    } else {\n      desired_positions[i] = current_positions[i];  // Mantener posici\u00f3n actual si no hay comando\n    }\n  }\n\n  // Calcular el vector de gravedad usando Pinocchio\n  std::vector&lt;double&gt; gravity = calculate_gravity_vector(current_positions);\n\n  // Calcular el error de posici\u00f3n y velocidad\n  std::vector&lt;double&gt; position_error(joint_names_.size(), 0.0);\n\n  for (size_t i = 0; i &lt; joint_names_.size(); ++i) {\n    position_error[i] = desired_positions[i] - current_positions[i];\n  }\n\n  // Calcular el comando de torque usando PD con compensaci\u00f3n de gravedad\n  // tau = Kp * (q_d - q) - Kd * q_dot + g(q)\n  std::vector&lt;double&gt; torque_command(joint_names_.size(), 0.0);\n\n  for (size_t i = 0; i &lt; joint_names_.size(); ++i) {\n     torque_command[i] = kp_[i] * position_error[i] - \n                      kd_[i] * current_velocities[i] + \n                      gravity[i];\n  }\n\n  // Aplicar el comando de torque\n  for (size_t i = 0; i &lt; joint_names_.size(); ++i) {\n    if (!command_interfaces_[i].set_value(torque_command[i])) {\n      RCLCPP_ERROR(\n          get_node()-&gt;get_logger(), \n          \"Failed to set command interface value for joint %zu\", \n          i\n      );\n      return controller_interface::return_type::ERROR;\n    }\n  }\n\n  if (state_publisher_ &amp;&amp; state_publisher_-&gt;trylock()) {\n    state_publisher_-&gt;msg_.header.stamp = time;\n    state_publisher_-&gt;msg_.set_point = desired_positions[0];  // Publicar la posici\u00f3n deseada\n\n    state_publisher_-&gt;unlockAndPublish();\n  }\n\n  return controller_interface::return_type::OK;\n}\n</code></pre></p> <p>Tambi\u00e9n ser\u00e1 necesario modificar el fichero de encabezado rrbot_controller.hpp para incluir las dependencias: <pre><code>#include &lt;pinocchio/multibody/model.hpp&gt;\n#include &lt;pinocchio/multibody/data.hpp&gt;\n\n#include &lt;hardware_interface/loaned_state_interface.hpp&gt;\n</code></pre> La secci\u00f3n protected de este fichero ser\u00eda la siguiente: <pre><code>std::vector&lt;double&gt; calculate_gravity_vector(const std::vector&lt;double&gt;&amp; q);\n\n  std::vector&lt;std::string&gt; joint_names_;\n  std::string interface_name_;\n\n  // Command subscribers and Controller State publisher\n  using ControllerCommandMsg = control_msgs::msg::JointJog;\n\n  // Command subscribers and Controller State publisher\n  using ControllerStateMsg = control_msgs::msg::JointControllerState;\n  using ControllerStatePublisher =\n  realtime_tools::RealtimePublisher&lt;ControllerStateMsg&gt;;\n\n  // Par\u00e1metros del controlador PD\n  std::vector&lt;double&gt; kp_;  // Ganancia proporcional\n  std::vector&lt;double&gt; kd_;  // Ganancia derivativa\n\n  // Modelo y datos de Pinocchio\n  std::shared_ptr&lt;pinocchio::Model&gt; model_;\n  std::shared_ptr&lt;pinocchio::Data&gt; data_;\n  std::vector&lt;pinocchio::JointIndex&gt; joint_indices_;  // \u00cdndices de las articulaciones en el modelo\n\n  // Interfaces de estado organizadas\n  std::vector&lt;std::reference_wrapper&lt;hardware_interface::LoanedStateInterface&gt;&gt; position_state_interfaces_;\n  std::vector&lt;std::reference_wrapper&lt;hardware_interface::LoanedStateInterface&gt;&gt; velocity_state_interfaces_;\n\n  // Subscriber para comandos y buffer\n  rclcpp::Subscription&lt;ControllerCommandMsg&gt;::SharedPtr command_subscriber_;\n  realtime_tools::RealtimeBuffer&lt;std::shared_ptr&lt;ControllerCommandMsg&gt;&gt; input_command_;\n\n  // Publisher para estado\n  rclcpp::Publisher&lt;ControllerStateMsg&gt;::SharedPtr s_publisher_;\n  std::unique_ptr&lt;ControllerStatePublisher&gt; state_publisher_;\n</code></pre> Adem\u00e1s, es necesario actualizar el archivo YAML rrbot_controllers_custom.yaml para incluir las ganancias de los controladores y la ruta del archivo URDF: <pre><code># Controller manager configuration\ncontroller_manager:\n  ros__parameters:\n    update_rate: 50  # Hz\n    # Define a name for controllers that we plan to use\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n    rrbot_controller:\n      type: rrbot_controller/RRBotController\n\n# Properties of the custom controler and definition of joints to use\nrrbot_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n    interface_name: position  # Se mantiene por compatibilidad\n\n    # Ganancias del controlador PD\n    kp: [100.0, 100.0]  # Ganancia proporcional para cada articulaci\u00f3n\n    kd: [10.0, 10.0]    # Ganancia derivativa para cada articulaci\u00f3n\n\n    # Ruta del archivo URDF para Pinocchio\n    robot_description_path: \"/home/ubuntu/ros2_ws/src/ros2_robot_sca/description/urdf/model.urdf\"\n</code></pre></p> <p>Antes de poder compilar todo ser\u00e1 necesario instalar pinocchio: <pre><code>sudo apt-get install ros-jazzy-pinocchio\n</code></pre> Tambi\u00e9n es necesario actualizar las dependencias del paquete rrbot_controller. Para ello, se debe a\u00f1adir Pinocchio como dependencia en el archivo package.xml: <pre><code>&lt;depend&gt;pinocchio&lt;/depend&gt;\n</code></pre> Adem\u00e1s, habr\u00e1 que actualizar CMakeLists.txt para a\u00f1adir las dependencias a pinocchio y eigen3: <pre><code>cmake_minimum_required(VERSION 3.5)\nproject(rrbot_controller)\n\n# Default to C++14\nif(NOT CMAKE_CXX_STANDARD)\n  set(CMAKE_CXX_STANDARD 14)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\n# find dependencies\nfind_package(ament_cmake REQUIRED)\nfind_package(control_msgs REQUIRED)\nfind_package(controller_interface REQUIRED)\nfind_package(hardware_interface REQUIRED)\nfind_package(pluginlib REQUIRED)\nfind_package(rclcpp REQUIRED)\nfind_package(rclcpp_lifecycle REQUIRED)\nfind_package(realtime_tools REQUIRED)\nfind_package(example_interfaces REQUIRED)\n\nfind_package(pinocchio REQUIRED)\nfind_package(Eigen3 REQUIRED NO_MODULE)\n\n\nadd_library(\n  rrbot_controller\n  SHARED\n  src/rrbot_controller.cpp\n)\ntarget_include_directories(\n  rrbot_controller\n  PUBLIC\n  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;\n  $&lt;INSTALL_INTERFACE:include&gt;\n)\nament_target_dependencies(\n  rrbot_controller\n  control_msgs\n  controller_interface\n  hardware_interface\n  pluginlib\n  rclcpp\n  rclcpp_lifecycle\n  realtime_tools\n)\n\n\ntarget_link_libraries(rrbot_controller\n  pinocchio::pinocchio\n  Eigen3::Eigen\n)\n\n# prevent pluginlib from using boost\ntarget_compile_definitions(rrbot_controller PUBLIC \"PLUGINLIB__DISABLE_BOOST_FUNCTIONS\")\n\npluginlib_export_plugin_description_file(\n  controller_interface rrbot_controller.xml)\n\ninstall(\n  TARGETS\n  rrbot_controller\n  RUNTIME DESTINATION bin\n  ARCHIVE DESTINATION lib\n  LIBRARY DESTINATION lib\n)\n\ninstall(\n  DIRECTORY include/\n  DESTINATION include\n)\n\nament_export_include_directories(\n  include\n)\nament_export_libraries(\n  rrbot_controller\n)\nament_export_dependencies(\n  control_msgs\n  controller_interface\n  hardware_interface\n  pluginlib\n  rclcpp\n  rclcpp_lifecycle\n  realtime_tools\n  pinocchio\n  Eigen3\n)\n\nament_package()\n</code></pre></p>"},{"location":"controlador_propio/#recompilar-y-probar-el-nuevo-controlador_1","title":"Recompilar y probar el nuevo controlador","text":"<p>Ahora se debe recompilar y ejecutar source antes de continuar y probar el controlador en el robot. Es necesario recompilar para que el nuevo archivo de lanzamiento y el archivo de configuraci\u00f3n se copien en el espacio de instalaci\u00f3n. <pre><code>cd ~/ros2_ws\n</code></pre></p> <p><pre><code>colcon build\n</code></pre> Puede que obtengas bastantes warnings de Eigen y Pinocchio sobre posibles variables no inicializadas en los constructores. Estas advertencias no deber\u00edan impedir que tu controlador se compile correctamente. </p> <p><pre><code>source install/setup.bash\n</code></pre> Ejecuta el nuevo archivo de lanzamiento que genera el robot e inicia el nuevo controlador: <pre><code>ros2 launch my_robot_bringup rrbot_with_rrbot_controller.launch.py\n</code></pre> En otra terminal confirmar que el nuevo controlador est\u00e1 activo (debe aparece el controlador rrbot_controller): <pre><code>ros2 control list_controllers\n</code></pre> A continuaci\u00f3n probar a mover las articulaciones del robot utilizando el nuevo controlador: <pre><code>ros2 topic pub /rrbot_controller/commands control_msgs/msg/JointJog \"{joint_names: ['joint_1', 'joint_2'], displacements: [0.5, 0.3]}\"\n</code></pre></p> <p>Ejercicio</p> <ul> <li>Ajustar el controlador PD con compensaci\u00f3n de gravedad.</li> <li>Comparar el comportamiento del controlador PD con compensaci\u00f3n de gravedad frente a un controlador PD.</li> <li>Implementar un controlador PID y ajustarlo correctamente.</li> <li>Comparar el comportamiento de los tres controladores: PD, PD con compensaci\u00f3n de gravedad y PID.</li> </ul>"},{"location":"hardware/","title":"Interfaz hardware","text":"<p>Despu\u00e9s de que el controlador calcula la acci\u00f3n de control, su salida se env\u00eda a una interfaz hardware. Una interfaz hardware es un componente software que puede comunicarse con ROS2_control en un extremo y con uno o m\u00e1s dispositivos de hardware en el otro extremo.</p> <p>Por ejemplo, sup\u00f3ngase que se tiene un sensor de posici\u00f3n que obtiene lecturas de datos de posici\u00f3n. Estas lecturas sin procesar son recibidas por la interfaz hardware y enviadas a un controlador que est\u00e1 escuchando esos datos. Cuando el controlador produce un nuevo comando, \u00e9ste es recibido por la interfaz hardware. Luego, este comando se transforma en el formato de datos espec\u00edfico requerido y comprendido por el dispositivo hardware. Por lo tanto, se puede ver una interfaz hardware como un intermediario e int\u00e9rprete que traduce los datos del hardware al controlador y viceversa.</p> <p>En realidad, la interfaz hardware y ros2_control est\u00e1n acopladas mediante una interfaz de plugin. En t\u00e9rminos t\u00e9cnicos, decimos que ros2_control implementa una \"clase abstracta\" y la interfaz hardware implementa la \"clase derivada\". De esta manera, el algoritmo de control no tiene que conocer los detalles espec\u00edficos del hardware. Y como la interfaz de hardware es un plugin, no crea un nodo ROS2. En los siguientes apartados se ir\u00e1n viendo m\u00e1s detalles de todo esto y se aplicar\u00e1n a nuestro robot de dos grados de libertad.</p>"},{"location":"hardware/#tipos-de-interfaz-hardware","title":"Tipos de interfaz hardware","text":"<p>El framework ros2_control proporciona un conjunto de tipos de interfaces hardware que se pueden utilizar para implementar un componente de hardware para un robot o dispositivo espec\u00edfico. Las siguientes secciones describen los diferentes tipos de interfaces hardware y su uso.</p> <p>El hardware en ros2_control se describe mediante un URDF. La definici\u00f3n se puede encontrar en el repositorio de ros2_control. Puedes consultar las estructuras definidas all\u00ed para ver qu\u00e9 atributos est\u00e1n disponibles para cada una de las etiquetas XML. A continuaci\u00f3n se proporciona un ejemplo gen\u00e9rico que muestra la estructura (m\u00e1s abajo se describir\u00e1 un nuevo ejemplo en la secci\u00f3n \"ejemplo\").</p> Example <pre><code>&lt;ros2_control name=\"Name_of_the_hardware\" type=\"system\"&gt;\n&lt;hardware&gt;\n    &lt;plugin&gt;library_name/ClassName&lt;/plugin&gt;\n    &lt;!-- added to hardware_parameters --&gt;\n    &lt;param name=\"example_param\"&gt;value&lt;/param&gt;\n&lt;/hardware&gt;\n&lt;joint name=\"name_of_the_component\"&gt;\n    &lt;command_interface name=\"interface_name\"&gt;\n        &lt;!-- All of them are optional. `data_type` and `size` are used for GPIOs. Size is length of an array. --&gt;\n        &lt;param name=\"min\"&gt;-1&lt;/param&gt;\n        &lt;param name=\"max\"&gt;1&lt;/param&gt;\n        &lt;param name=\"initial_value\"&gt;0.0&lt;/param&gt;\n        &lt;param name=\"data_type\"&gt;&lt;/param&gt;\n        &lt;param name=\"size\"&gt;5&lt;/param&gt;\n        &lt;!-- Optional. Added to the key/value storage parameters --&gt;\n        &lt;param name=\"own_param_1\"&gt;some_value&lt;/param&gt;\n        &lt;param name=\"own_param_2\"&gt;other_value&lt;/param&gt;\n    &lt;/command_interface&gt;\n    &lt;!-- Short form to define StateInterface. Can be extended like CommandInterface. --&gt;\n    &lt;state_interface name=\"position\"/&gt;\n&lt;/joint&gt;\n&lt;/ros2_control&gt;\n</code></pre>"},{"location":"hardware/#articulaciones","title":"Articulaciones","text":"<p>La etiqueta <code>&lt;joint&gt;</code> agrupa las interfaces asociadas con las articulaciones de los robots f\u00edsicos y los actuadores. Tienen interfaces de comando (<code>&lt;command_interface name=\"interface_name\"&gt;</code>) y de estado (<code>&lt;state_interface name=\"position\"/&gt;</code>) para establecer los valores objetivo para el hardware y leer su estado actual.</p> <p>Todas las articulaciones definidas en la etiqueta <code>&lt;ros2_control&gt;</code> deben estar presentes en el URDF recibido por el controller manager. Las interfaces de estado de las articulaciones pueden ser publicadas como un topic de ROS mediante el joint_state_broadcaster.</p>"},{"location":"hardware/#sensores","title":"Sensores","text":"<p>La etiqueta <code>&lt;sensor&gt;</code> agrupa m\u00faltiples interfaces de estado que describen, por ejemplo, los estados internos del hardware. Dependiendo del tipo de sensor, existen algunos componentes sem\u00e1nticos espec\u00edficos con emisores (broadcasters) proporcionados por ros2_controllers.</p>"},{"location":"hardware/#gpios","title":"GPIOs","text":"<p>La etiqueta <code>&lt;gpio&gt;</code> se utiliza para describir puertos de entrada y salida de un dispositivo rob\u00f3tico que no pueden asociarse con ninguna articulaci\u00f3n o sensor. El an\u00e1lisis de la etiqueta <code>&lt;gpio&gt;</code> es similar al de la etiqueta <code>&lt;joint&gt;</code>, teniendo interfaces de comando y de estado. La etiqueta debe tener al menos una etiqueta <code>&lt;command&gt;</code> o <code>&lt;state&gt;</code> como hija.</p> <p>La palabra clave \"gpio\" se eligi\u00f3 por su generalidad. Aunque se usa estrictamente para se\u00f1ales digitales, describe cualquier se\u00f1al el\u00e9ctrica anal\u00f3gica, digital o valor f\u00edsico. La etiqueta <code>&lt;gpio&gt;</code> puede usarse como hija de los tres tipos de componentes de hardware, es decir, sistema, sensor o actuador.</p> <p>Debido a que los puertos implementados como <code>&lt;gpio&gt;</code> suelen ser muy espec\u00edficos de la aplicaci\u00f3n, no existe un emisor gen\u00e9rico dentro del marco ros2_control. Se debe implementar un controlador GPIO personalizado para cada aplicaci\u00f3n. </p>"},{"location":"hardware/#grupos-de-hardware","title":"Grupos de Hardware","text":"<p>Los grupos de componentes hardware sirven como un mecanismo organizacional cr\u00edtico dentro de sistemas complejos, facilitando el manejo de errores y la tolerancia a fallos. Al agrupar componentes de hardware relacionados, como los actuadores dentro de un manipulador, los usuarios pueden establecer un marco unificado para la detecci\u00f3n de errores y la respuesta.</p> <p>Los grupos de componentes hardware juegan un papel vital en la propagaci\u00f3n de errores a trav\u00e9s de los componentes de hardware interconectados. Por ejemplo, en un sistema manipulador, agrupar los actuadores permite la propagaci\u00f3n de errores. Si un actuador falla dentro del grupo, el error puede propagarse a los otros actuadores, se\u00f1alando un posible problema en todo el sistema. De forma predeterminada, los errores de los actuadores se a\u00edslan en su propio componente de hardware, lo que permite que el resto contin\u00fae funcionando sin verse afectado. En la configuraci\u00f3n proporcionada de ros2_control, la etiqueta <code>&lt;group&gt;</code> dentro de cada bloque <code>&lt;ros2_control&gt;</code> significa el agrupamiento de componentes de hardware, habilitando los mecanismos de propagaci\u00f3n de errores dentro del sistema.</p>"},{"location":"hardware/#ejemplo","title":"Ejemplo","text":"<p>El siguiente ejemplo muestra c\u00f3mo usar los diferentes tipos de interfaces hardware en un URDF de ros2_control. Estos pueden combinarse dentro de los diferentes tipos de componentes hardware (sistema, actuador, sensor) de la siguiente manera:</p> <p>Sistema RRBot con m\u00faltiples interfaces GPIO</p> <ul> <li>Digital: 4 entradas y 2 salidas</li> <li>Anal\u00f3gico: 2 entradas y 1 salida</li> <li>V\u00e1lvula de vac\u00edo en la brida (encendido/apagado)*</li> </ul> Example <pre><code>&lt;ros2_control name=\"RRBotSystemMutipleGPIOs\" type=\"system\"&gt;\n    &lt;hardware&gt;\n        &lt;plugin&gt;ros2_control_demo_hardware/RRBotSystemPositionOnlyHardware&lt;/plugin&gt;\n        &lt;param name=\"example_param_hw_start_duration_sec\"&gt;2.0&lt;/param&gt;\n        &lt;param name=\"example_param_hw_stop_duration_sec\"&gt;3.0&lt;/param&gt;\n        &lt;param name=\"example_param_hw_slowdown\"&gt;2.0&lt;/param&gt;\n    &lt;/hardware&gt;\n    &lt;joint name=\"joint1\"&gt;\n        &lt;command_interface name=\"position\"&gt;\n            &lt;param name=\"min\"&gt;-1&lt;/param&gt;\n            &lt;param name=\"max\"&gt;1&lt;/param&gt;\n        &lt;/command_interface&gt;\n        &lt;state_interface name=\"position\"/&gt;\n    &lt;/joint&gt;\n    &lt;joint name=\"joint2\"&gt;\n        &lt;command_interface name=\"position\"&gt;\n            &lt;param name=\"min\"&gt;-1&lt;/param&gt;\n            &lt;param name=\"max\"&gt;1&lt;/param&gt;\n        &lt;/command_interface&gt;\n        &lt;state_interface name=\"position\"/&gt;\n    &lt;/joint&gt;\n    &lt;gpio name=\"flange_digital_IOs\"&gt;\n        &lt;command_interface name=\"digital_output1\"/&gt;\n        &lt;state_interface name=\"digital_output1\"/&gt;    &lt;!-- Needed to know current state of the output --&gt;\n        &lt;command_interface name=\"digital_output2\"/&gt;\n        &lt;state_interface name=\"digital_output2\"/&gt;\n        &lt;state_interface name=\"digital_input1\"/&gt;\n        &lt;state_interface name=\"digital_input2\"/&gt;\n    &lt;/gpio&gt;\n    &lt;gpio name=\"flange_analog_IOs\"&gt;\n        &lt;command_interface name=\"analog_output1\"/&gt;\n        &lt;state_interface name=\"analog_output1\"&gt;    &lt;!-- Needed to know current state of the output --&gt;\n            &lt;param name=\"initial_value\"&gt;3.1&lt;/param&gt;  &lt;!-- Optional initial value for mock_hardware --&gt;\n        &lt;/state_interface&gt;\n        &lt;state_interface name=\"analog_input1\"/&gt;\n        &lt;state_interface name=\"analog_input2\"/&gt;\n    &lt;/gpio&gt;\n    &lt;gpio name=\"flange_vacuum\"&gt;\n        &lt;command_interface name=\"vacuum\"/&gt;\n        &lt;state_interface name=\"vacuum\"/&gt;    &lt;!-- Needed to know current state of the output --&gt;\n    &lt;/gpio&gt;\n&lt;/ros2_control&gt;\n</code></pre>"},{"location":"hardware/#control-en-posicion-velocidad-y-aceleracion","title":"Control en posici\u00f3n, velocidad y aceleraci\u00f3n","text":"<p>Una vez descritos los principales aspectos te\u00f3ricos de los interfaces hardware, en este apartado se va a modificar el interfaz hardware de nuestro robot de dos grados de libertad para permitir el control en posici\u00f3n, velocidad y esfuerzo (recuerda que hasta ahora s\u00f3lo permit\u00eda enviarle comandos de posici\u00f3n). Para ello, modificar el fichero rrbot.ros2_control.xacro que se encuentra en ros2_robot_sca/description/ros2_control para incluir las interfaces de velocidad y aceleraci\u00f3n. Por ejemplo, la definici\u00f3n para joint1 deber\u00eda ser la siguiente:</p> <pre><code>    &lt;joint name=\"joint1\"&gt;\n      &lt;command_interface name=\"position\"&gt;\n        &lt;param name=\"min\"&gt;-1&lt;/param&gt;\n        &lt;param name=\"max\"&gt;1&lt;/param&gt;\n      &lt;/command_interface&gt;\n      &lt;command_interface name=\"velocity\"&gt;\n        &lt;param name=\"min\"&gt;-1&lt;/param&gt;\n        &lt;param name=\"max\"&gt;1&lt;/param&gt;\n      &lt;/command_interface&gt;\n      &lt;command_interface name=\"effort\"&gt;\n        &lt;param name=\"min\"&gt;-1&lt;/param&gt;\n        &lt;param name=\"max\"&gt;1&lt;/param&gt;\n      &lt;/command_interface&gt;\n      &lt;state_interface name=\"position\"/&gt;\n      &lt;state_interface name=\"velocity\"/&gt;\n      &lt;state_interface name=\"effort\"/&gt;\n    &lt;/joint&gt;\n</code></pre> <p>Se observa que se ha incluido las tres interfaces de comando (posici\u00f3n, velocidad y esfuerzo) para permitir que la articulaci\u00f3n pueda ser accionada con comandos de posici\u00f3n, velocidad o esfuerzo. Adem\u00e1s, se han incluido esas mismas interfaces de estado, lo que permitir\u00e1 al controlador obtener una realimentaci\u00f3n de las tres variables  y conocer su valor en cada momento. Repetir lo mismo para joint2. </p> <p>A continuaci\u00f3n modificar el fichero de configuraci\u00f3n controller_configuration.yaml, que se encuentra en my_robot_bringup/config, para definir controladores de velocidad y esfuerzo. Para ello, editar el fichero controller_configuration.yaml y modificar la secci\u00f3n de controladores disponibles para que incluya los siguientes:</p> <pre><code>    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    forward_position_controller:\n      type: position_controllers/JointGroupPositionController\n\n    forward_velocity_controller:\n      type: velocity_controllers/JointGroupVelocityController\n\n    forward_effort_controller:\n      type: effort_controllers/JointGroupEffortController\n</code></pre> <p>Se observa que se han definido tres controladores (adicionales al joint_state broadcaster). El controlador <code>forward_position controller</code> es un contrador de tipo <code>position_controllers/JointGroupPositionController</code>, por lo tanto, genera una acci\u00f3n de control de posici\u00f3n (aceptar\u00e1 tambi\u00e9n consignas de posici\u00f3n). El controlador <code>forward_velocity_controller</code> es de tipo <code>velocity_controllers/JointGroupVelocityController</code>. En este caso, genera una acci\u00f3n de control de velocidad (aceptando consignas de velocidad). Por \u00faltimo, el controlador <code>forward_effort_controller</code> es definido como <code>effort_controllers/JointGroupEffortController</code>, por lo tanto, implementa un controlador que manda dirctamente un esfuerzo articular.</p> <p>Adem\u00e1s, incluir la siguiente informaci\u00f3n en el fichero controller_configuration.yaml en la parte de propiedades de los controladores (borrar previamente la informaci\u00f3n que conten\u00eda el fichero .yaml en este apartado):</p> <p><pre><code>forward_position_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n    interface_name: position\n\nforward_velocity_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n    interface_name: velocity\n\nforward_effort_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n    interface_name: effort\n</code></pre> Con este c\u00f3digo se est\u00e1 asignando los tres controladores definidos anteriormente a las interfaces correspondientes.</p> <p>Por \u00faltimo, habr\u00eda que modificar el fichero my_robot.launch.py para cargar el controlador correspondiente (forward_position_controller, forward_velocity_controller o forward_effort_controller) para las articulaciones. Recordar que en el fichero launch se cargaba el controlador <code>forward_position_controller</code> mediante este c\u00f3digo: <pre><code>    robot_controller_spawner = Node(\n        package=\"controller_manager\",\n        executable=\"spawner\",\n        arguments=[\"forward_position_controller\", \"--param-file\", robot_controllers],\n    )\n</code></pre> Se va a modificar para que pueda especificarse el controlador mediante un par\u00e1metro. Esto puede conseguirse siguiendo los siguientes pasos:</p> <p>Primero, a\u00f1adir la informaci\u00f3n del nuevo par\u00e1metro en la definici\u00f3n del fichero launch:</p> <pre><code>    declared_arguments.append(\n        DeclareLaunchArgument(\n            \"robot_controller\",\n            default_value=\"forward_velocity_controller\",\n            description=\"Robot controller to start.\",\n        )\n    )\n</code></pre> <p>En el apartado de inicializaci\u00f3n de los argumentos incluir esta instrucci\u00f3n: <pre><code>robot_controller = LaunchConfiguration(\"robot_controller\")\n</code></pre></p> <p>La llamada al controlador correpondiente se obtendr\u00e1 mediante la siguiente instrucci\u00f3n (eliminar previamente la instrucci\u00f3n original <code>robot_controller_spawner = Node(...)</code>): <pre><code>    robot_controller_spawner = Node(\n        package=\"controller_manager\",\n        executable=\"spawner\",\n        arguments=[robot_controller, \"--param-file\", robot_controllers],\n    )\n</code></pre></p> <p>Una vez hecho estos cambios, ejecutar los siguienes comandos y comprobar si todo est\u00e1 correcto: <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build\nsource install/setup.bash\n</code></pre> se puede cargar el robot con el controlador correspondiente mediante: <pre><code>ros2 launch my_robot_bringup my_robot.launch.py\n</code></pre></p> <p>Por defecto se ejecutar\u00e1 el velocity controller, puede cambiarse el controlador mediante la siguiente opci\u00f3n para el controlador de posici\u00f3n: <pre><code>ros2 launch my_robot_bringup my_robot.launch.py robot_controller:=forward_position_controller\n</code></pre> O para el controlador de esfuerzo: <pre><code>ros2 launch my_robot_bringup my_robot.launch.py robot_controller:=forward_effort_controller\n</code></pre> En otra terminal se pueden comprobar los interfaces disponibles mediante el siguiente comando: <pre><code>ros2 control list_hardware_interfaces\n</code></pre> Se obtendr\u00e1 lo siguiente si has cargado un controlador de posici\u00f3n:</p> <p></p> <p>El marcador [claimed] de cada interfaz significa que un controlador tiene acceso al comando RRBot.</p> <p>Verifica qu\u00e9 controladores est\u00e1n en ejecuci\u00f3n mediante este comando: <pre><code>ros2 control list_controllers\n</code></pre> Si se ha cargado el controlador de posici\u00f3n se obtiene lo siguiente:</p> <p></p> <p>Verifica c\u00f3mo cambia esta salida si usas los diferentes argumentos de lanzamiento descritos anteriormente.</p> <p>A continuaci\u00f3n puedes enviar comandos a los controladores para mover las articulaciones del robot. El comando cambiar\u00e1 dependiendo del controlador cargado:</p> <ul> <li>Cuando uses el controlador forward_position_controller: <pre><code>ros2 topic pub /forward_position_controller/commands std_msgs/msg/Float64MultiArray \"data:\n- 0.5\n- 0.5\"\n</code></pre></li> <li>Cuando uses el controlador forward_velocity_controller: <pre><code>ros2 topic pub /forward_velocity_controller/commands std_msgs/msg/Float64MultiArray \"data:\n- 5\n- 5\"\n</code></pre></li> <li>Cuando uses el controlador forward_effort_controller: <pre><code>ros2 topic pub /forward_effort_controller/commands std_msgs/msg/Float64MultiArray \"data:\n- 10\n- 10\"\n</code></pre></li> </ul> <p>Tambi\u00e9n puedes cambiar controladores durante la ejecuci\u00f3n, lo que tambi\u00e9n cambia autom\u00e1ticamente el modo de comando. Para ello, vamos a suponer que est\u00e1s utilizando un controlador tipo forward_velocity_controller. Recuerda que para eso puedes usar el siguiente comando: <pre><code>ros2 launch my_robot_bringup my_robot.launch.py robot_controller:=forward_velocity_controller\n</code></pre> Ahora vamos a cambiarlo por un controlador de posici\u00f3n (forward_position_controller). Para ello, utilizaremos los dos siguientes comandos: <pre><code>ros2 control load_controller forward_position_controller $(ros2 pkg prefix my_robot_bringup --share)/config/controller_configuration.yaml\n</code></pre> <pre><code>ros2 control set_controller_state forward_position_controller inactive\n</code></pre></p> <p>Ahora ya puedes cambiar controlador forward_velocity_controller por el forward_position_controller usando el siguiente comando: <pre><code>ros2 control switch_controllers --deactivate forward_velocity_controller --activate forward_position_controller\n</code></pre> Ahora ya puedes mandarle al robot comandos de posici\u00f3n. Comprobar los interfaces y controladores con los siguientes comandos: <pre><code>ros2 control list_controllers\n</code></pre> <pre><code>ros2 control list_hardware_interfaces\n</code></pre> </p> <p>Ejercicio</p> <p>Experimentar con los distintos controladores y comprobar la diferencia de comportamiento dependiendo del tipo de controlador/comando utilizado.</p>"},{"location":"hardware/#control-pid","title":"Control PID","text":"<p>En este apartado se incluir\u00e1 un nuevo tipo de controlador (PID) y se a\u00f1adir\u00e1n los cambios y par\u00e1metros necesarios para su funcionamiento. En primer lugar, se considerar\u00e1 un controlador PID con referencia posici\u00f3n y acci\u00f3n de control velocidad. Los cambios necesarios a a\u00f1adir al fichero controller_configuration.yaml para el nuevo controlador (pid_position_velocity_controller) son los que se muestran a continuaci\u00f3n.</p> <p>Primero a\u00f1adir el tipo de controlador: <pre><code>    pid_position_velocity_controller:\n      type: pid_controller/PidController\n</code></pre> Y despu\u00e9s incluir las caracter\u00edsticas del controlador: <pre><code>pid_position_velocity_controller:\n  ros__parameters:\n    dof_names:\n      - joint1\n      - joint2\n\n    command_interface: velocity  # Acci\u00f3n de control ser\u00e1 velocidad\n    reference_interface: position  # Referencia ser\u00e1 posici\u00f3n\n\n    # Configuraci\u00f3n de interfaces\n    reference_and_state_interfaces: \n      - position\n\n    # Ganancias PID para cada articulaci\u00f3n\n    gains:\n      joint1:\n        p: 10.0  # Ganancia proporcional\n        i: 0.1   # Ganancia integral\n        d: 0.01  # Ganancia derivativa\n        i_clamp_max: 1.0\n        i_clamp_min: -1.0\n        antiwindup: true\n\n      joint2:\n        p: 10.0\n        i: 0.1\n        d: 0.01\n        i_clamp_max: 1.0\n        i_clamp_min: -1.0\n        antiwindup: true\n</code></pre> Tras a\u00f1adir el controlador pid_position_velocity_controller al fichero controller_configuration.yaml, se deber\u00e1 probar si, utilizando este nuevo controlador, se alcanzan distintas posiciones de referencia. Para ello, se debe poder cargar el controlador con esta instrucci\u00f3n: <pre><code>ros2 launch my_robot_bringup my_robot.launch.py robot_controller:=pid_position_velocity_controller\n</code></pre> Si se quiere, por ejemplo, que el robot alcance la posici\u00f3n articular (0.5 0.5) rad para ambas articulaciones se puede utilizar el siguiente comando: <pre><code>ros2 topic pub /pid_position_velocity_controller/reference control_msgs/msg/MultiDOFCommand \"{\n    dof_names: ['joint1', 'joint2'], \n    values: [0.5, 0.5], \n    values_dot: [0.0, 0.0]\n}\"\n</code></pre></p> <p>Ejercicio</p> <p>Tratar de ajustar correctamente las constantes del controlador PID para que el robot se posicione sin oscilaciones (probar que se alcance bien para distintas posiciones de referencia).</p> <p>Para hacer el ajuste de las constantes proporcional, derivativa e integral, si ya tienes cargado el controlador PID, puedes cambiar estas constantes mediante comandos como los siguientes (desde otra terminal):</p> <ul> <li>Cambiar la ganancia P de joint1: <pre><code>ros2 param set /pid_position_velocity_controller gains.joint1.p 15.0\n</code></pre></li> <li>Cambiar la ganancia I de joint2: <pre><code>ros2 param set /pid_position_velocity_controller gains.joint2.i 0.2\n</code></pre></li> </ul> <p>Por \u00faltimo, una forma de evaluar si el robot se est\u00e1 posicionando correctamente, es obtener una gr\u00e1fica de la evoluci\u00f3n de las articulaciones en los distintos experimentos. Una forma f\u00e1cil de obtener las gr\u00e1ficas es usar una aplicaci\u00f3n como plotjuggler. En esta aplicaci\u00f3n se puede visualizar en tiempo real el estado de las articulaciones pulsando en start dentro del apartado Streaming (ROS2 Topic Subscriber) y seleccionar /joint_states. La posici\u00f3n de las articulaciones pueden monitorizarse en joint_states/position.</p> <p>Ejercicio</p> <p>Dise\u00f1ar un nuevo controlador con referencia posici\u00f3n y acci\u00f3n de control esfuerzo. Ajustarlo y probar que se alcancen bien distintas posiciones de referencia. Para ello, dise\u00f1ar un script que permita representar la evoluci\u00f3n de la posici\u00f3n de las articulaciones.</p>"},{"location":"ros2control/","title":"Los paquetes de ros2_control","text":"<p>Ros2_control es un conjunto de paquetes que incluyen los interfaces de los controladores, los manejadores de los controladores, transmisiones, interfaces hardware y la toolbox de control. Todos estos paquetes conjuntamente permiten interactuar y controlar las articulaciones y actuadores de un robot.</p> <p>Estos paquetes funcionan de la siguiente manera: los paquetes ros2_control utilizan como entrada los datos relativos acerca del estado de las articulaciones y una entrada de referencia articular. Adem\u00e1s, estos paquetes generan como salida el comando adecuado a los actuadores (habitualmente como un comando de esfuerzo, posici\u00f3n o velocidad), con el objetivo de que los valores articulares actuales (joint states) alcancen la referencia articular. Emplean un mecanismo gen\u00e9rico de control mediante realimentaci\u00f3n, t\u00edpicamente un controlador PID, para controlar la salida. Esta acci\u00f3n de control se transfiere al robot a trav\u00e9s del interfaz hardware.</p> <p>En primer lugar, se va a describir c\u00f3mo integrar los paquetes ros2_control con un entorno de simulaci\u00f3n de forma que sea posible controlar el robot simulado empleando esta herramienta. En la siguiente figura se muestra c\u00f3mo ros2_control puede interactuar bien con el robot simulado o bien con el robot real.</p> <p></p> <p>El bloque 3rd party representa la aplicaci\u00f3n que env\u00eda el objetivo o referencia a los paquetes ros2_control, que puede ser, por ejemplo, el stack Nav2 o la aplicaci\u00f3n MoveIt2. En esta figura tambi\u00e9n se ha representado en naranja el bloque ros2_control, el hardware interfaz en la parte derecha (que representa la conexi\u00f3n entre los diferentes controladores y el robot) y tanto el robot real como el simulado.</p>"},{"location":"ros2control/#controladores-para-manipuladores","title":"Controladores para manipuladores","text":"<p>Los paquetes ros2_control proporcionan un conjunto de controladores (controller plugins) para interactuar de diferente manera con las articulaciones de un robot. Los controladores disponibles para robots manipuladores son los siguientes:</p> <ul> <li>Controlador de Admitancia (Admittance Controller)</li> <li>Controladores de Esfuerzo (Effort Controllers)</li> <li>Controlador de Comando Directo (Forward Command Controller)</li> <li>Controlador de Pinza (Gripper Controller)</li> <li>Controlador de Trayectoria Articular (Joint Trajectory Controller)</li> <li>Controlador de Pinza Paralela (Parallel Gripper Controller)</li> <li>Controlador PID (PID Controller)</li> <li>Controladores de Posici\u00f3n (Position Controllers)</li> <li>Controladores de Velocidad (Velocity Controllers)</li> <li>Controlador de Comando GPIO (Gpio Command Controller)</li> </ul>"},{"location":"ros2control/#broadcasters","title":"Broadcasters","text":"<p>Los broadcasters se utilizan para publicar datos de sensores desde componentes de hardware a topics de ROS. En el contexto de ros2_control, los broadcasters siguen siendo controladores y usan la misma interfaz de controlador que los mencionados anteriormente.</p> <p>Los principales tipos de broadcasters son: </p> <ul> <li>Broadcasters de Sensor de Fuerza y Torque (Force Torque Sensor Broadcaster)</li> <li>Broadcasters de Sensor IMU (IMU Sensor Broadcaster)</li> <li>Broadcasters de Estado Articular (Joint State Broadcaster)</li> <li>Broadcasters de Sensor de Rango (Range Sensor Broadcaster)</li> <li>Broadcasters de Posici\u00f3n (Pose Broadcaster)</li> </ul>"},{"location":"ros2control/#parametros-comunes-de-los-controladores","title":"Par\u00e1metros Comunes de los Controladores","text":"<p>Cada controlador o broadcaster tiene algunos par\u00e1metros comunes. Estos par\u00e1metros deben configurarse antes de su activaci\u00f3n. Los par\u00e1metros comunes de los controladores son los siguientes:</p> <ul> <li>update_rate: Par\u00e1metro entero sin signo que representa la frecuencia con la que cada controlador/broadcaster ejecuta su ciclo de actualizaci\u00f3n. Si no se especifica, operan a la misma frecuencia que el controller_manager.</li> <li>is_async: Un par\u00e1metro booleano que indica si la actualizaci\u00f3n del controlador debe ejecutarse de forma as\u00edncrona.</li> </ul> <p>En los siguientes apartados se describir\u00e1n los controladores m\u00e1s comunes.</p>"},{"location":"ros2control/#forward_command_controller","title":"forward_command_controller","text":"<p>Esta es una clase base que implementa un controlador de prealimentaci\u00f3n o de comando directo (feedforward controller). Implementaciones espec\u00edficas de esta clase base se pueden encontrar en:</p> <ul> <li>position_controllers</li> <li>velocity_controllers</li> <li>effort_controllers</li> </ul>"},{"location":"ros2control/#tipo-de-interfaz-de-hardware","title":"Tipo de interfaz de hardware","text":"<p>Este controlador se puede utilizar para cualquier tipo de interfaz de hardware.</p>"},{"location":"ros2control/#interfaz-ros-2-del-controlador","title":"Interfaz ROS 2 del controlador","text":""},{"location":"ros2control/#topics","title":"T\u00f3pics","text":"<pre><code>~/commands (topic de entrada) [std_msgs::msg::Float64MultiArray]\n    Target joint commands\n</code></pre>"},{"location":"ros2control/#parametros","title":"Par\u00e1metros","text":"<p>Este controlador utiliza la biblioteca generate_parameter_library para gestionar sus par\u00e1metros.</p>"},{"location":"ros2control/#ejemplo","title":"Ejemplo","text":"<p>Ejemplo de fichero de configuraci\u00f3n YAML (ser\u00e1 utilizado m\u00e1s adelante):</p> Example <pre><code>controller_manager:\n    ros__parameters:\n        update_rate: 100  # Hz\n\n        forward_position_controller:\n            type: forward_command_controller/ForwardCommandController\n\nforward_position_controller:\n    ros__parameters:\n        joints:\n            - slider_to_cart\n</code></pre> <p>En este c\u00f3digo se definen los par\u00e1metros para el gestor de controladores (controller_manager). En primer lugar se define la frecuencia de realimentaci\u00f3n del controlador a 100 Hz. Adem\u00e1s, se define un controlador tipo forward_command_controller/ForwardCommandController el cual se denomina forward_position_controller. Adem\u00e1s, se asigna este controlador a la articulaci\u00f3n slider_to_cart. Un controlador tipo forward_command_controller/ForwardCommandController simplemente genera como acci\u00f3n de control el valor de su consigna.</p>"},{"location":"ros2control/#position_controllers","title":"Position_controllers","text":"<p>Se trata de una colecci\u00f3n de controladores que funcionan utilizando la interfaz de comando articular de \u201cposici\u00f3n\u201d. Es una especializaci\u00f3n del forward_command_controller que funciona utilizando la interfaz articular de \u201cposici\u00f3n\u201d. El paquete contiene los siguientes controladores:</p> <pre><code>position_controllers/JointGroupPositionController\n</code></pre>"},{"location":"ros2control/#interfaz-ros-2-del-controlador_1","title":"Interfaz ROS 2 del controlador","text":""},{"location":"ros2control/#topics_1","title":"T\u00f3pics","text":"<pre><code>~/commands (t\u00f3pico de entrada) [std_msgs::msg::Float64MultiArray] \n    Comandos de posici\u00f3n para las articulaciones\n</code></pre>"},{"location":"ros2control/#parametros_1","title":"Par\u00e1metros","text":"<p>Este controlador sobrescribe el par\u00e1metro de interfaz de forward_command_controller, y el \u00fanico par\u00e1metro obligatorio es joints.</p>"},{"location":"ros2control/#ejemplo_1","title":"Ejemplo","text":"<p>Ejemplo de fichero de configuraci\u00f3n yaml.</p> Example <pre><code>controller_manager:\n    ros__parameters:\n        update_rate: 100  # Hz\n\n        position_controller:\n            type: position_controllers/JointGroupPositionController\n\nposition_controller:\n    ros__parameters:\n        joints:\n            - slider_to_cart\n</code></pre>"},{"location":"ros2control/#velocity_controllers","title":"Velocity_controllers","text":"<p>Se trata de una colecci\u00f3n de controladores que funcionan utilizando la interfaz de comando articular de \u201cvelocidad\u201d. Es una especializaci\u00f3n del forward_command_controller que funciona utilizando la interfaz articular de \u201cvelocidad\u201d. El paquete contiene los siguientes controladores:</p> <pre><code>velocity_controllers/JointGroupVelocityController\n</code></pre>"},{"location":"ros2control/#interfaz-ros-2-del-controlador_2","title":"Interfaz ROS 2 del controlador","text":""},{"location":"ros2control/#topics_2","title":"T\u00f3pics","text":"<pre><code>~/commands (t\u00f3pico de entrada) [std_msgs::msg::Float64MultiArray] \n    Comandos de velocidad para las articulaciones\n</code></pre>"},{"location":"ros2control/#parametros_2","title":"Par\u00e1metros","text":"<p>Este controlador sobrescribe el par\u00e1metro de interfaz de forward_command_controller, y el \u00fanico par\u00e1metro obligatorio es joints.</p>"},{"location":"ros2control/#ejemplo_2","title":"Ejemplo","text":"<p>Ejemplo de fichero de configuraci\u00f3n yaml.</p> Example <pre><code>controller_manager:\n    ros__parameters:\n        update_rate: 100  # Hz\n\n        velocity_controller:\n            type: velocity_controllers/JointGroupVelocityController\n\nvelocity_controller:\n    ros__parameters:\n        joints:\n            - slider_to_cart\n</code></pre>"},{"location":"ros2control/#effort_controllers","title":"Effort_controllers","text":"<p>Se trata de una colecci\u00f3n de controladores que funcionan utilizando la interfaz de comando articular de \u201cesfuerzo o par\u201d. Es una especializaci\u00f3n del forward_command_controller que funciona utilizando la interfaz articular de \u201cesfuerzo\u201d. El paquete contiene los siguientes controladores:</p> <pre><code>effort_controllers/JointGroupEffortController\n</code></pre>"},{"location":"ros2control/#interfaz-ros-2-del-controlador_3","title":"Interfaz ROS 2 del controlador","text":""},{"location":"ros2control/#topics_3","title":"T\u00f3pics","text":"<pre><code>~/commands (t\u00f3pico de entrada) [std_msgs::msg::Float64MultiArray] \n    Comandos de esfuerzo para las articulaciones\n</code></pre>"},{"location":"ros2control/#parametros_3","title":"Par\u00e1metros","text":"<p>Este controlador sobrescribe el par\u00e1metro de interfaz de forward_command_controller, y el \u00fanico par\u00e1metro obligatorio es joints.</p>"},{"location":"ros2control/#ejemplo_3","title":"Ejemplo","text":"<p>Ejemplo de fichero de configuraci\u00f3n yaml.</p> Example <pre><code>controller_manager:\n    ros__parameters:\n        update_rate: 100  # Hz\n\n        effort_controller:\n            type: effort_controllers/JointGroupEffortController\n\neffort_controller:\n    ros__parameters:\n        joints:\n            - slider_to_cart\n</code></pre>"},{"location":"ros2control/#controlador-pid","title":"Controlador PID","text":"<p>Se trata de una implementaci\u00f3n de un controlador PID que se basa en el paquete PidROS de control_toolbox. El controlador puede usarse directamente enviando referencias a trav\u00e9s de un t\u00f3pic. Tambi\u00e9n permite utilizar la primera derivada de la referencia y su realimentaci\u00f3n para lograr un control PID de segundo orden.</p> <p>Dependiendo de la interfaz de referencia/estado y la acci\u00f3n de control enviada al hardware, se debe utilizar una configuraci\u00f3n de par\u00e1metros diferente de PidROS, por ejemplo:</p> <ul> <li>Referencia/Estado: POSICI\u00d3N; Acci\u00f3n de control: VELOCIDAD \u2192 Controlador PI</li> <li>Referencia/Estado: VELOCIDAD; Acci\u00f3n de control: ACELERACI\u00d3N \u2192 Controlador PI</li> <li>Referencia/Estado: VELOCIDAD; Acci\u00f3n de control: POSICI\u00d3N \u2192 Controlador PD</li> <li>Referencia/Estado: ACELERACI\u00d3N; Acci\u00f3n de control: VELOCIDAD \u2192 Controlador PD</li> <li>Referencia/Estado: POSICI\u00d3N; Acci\u00f3n de control: POSICI\u00d3N \u2192 Controlador PID</li> <li>Referencia/Estado: VELOCIDAD; Acci\u00f3n de control: VELOCIDAD \u2192 Controlador PID</li> <li>Referencia/Estado: ACELERACI\u00d3N; Acci\u00f3n de control: ACELERACI\u00d3N \u2192 Controlador PID</li> <li>Referencia/Estado: ESFUERZO; Acci\u00f3n de control: ESFUERZO \u2192 Controlador PID</li> </ul> <p>Si se utiliza un solo tipo de interfaz de referencia y estado, solo se considera el error inmediato. Si se usan dos tipos, entonces la segunda interfaz se considera la primera derivada de la primera. Por ejemplo, una combinaci\u00f3n v\u00e1lida ser\u00eda las interfaces de posici\u00f3n y velocidad.</p> <p>Pluginlib-Library: pid_controller Plugin name: pid_controller/PidController</p>"},{"location":"ros2control/#interfaz-ros-2-del-controlador_4","title":"Interfaz ROS 2 del controlador","text":""},{"location":"ros2control/#topics_4","title":"Topics","text":"<pre><code>&lt;dof_names[i]&gt;/&lt;command_interface&gt; [double]\n</code></pre>"},{"location":"ros2control/#parametros_4","title":"Par\u00e1metros","text":""},{"location":"ros2control/#dof_names-string_array","title":"dof_names (string_array)","text":"<p>Especifica dof_names o ejes utilizados por el controlador. Si se define el estado \"reference_and_state_dof_names\", entonces con este par\u00e1metro solo se define lo nombres de los grados de libertad controlados.</p> <p>Read only: True</p> <p>Default: {}</p>"},{"location":"ros2control/#reference_and_state_dof_names-string_array-opcional","title":"reference_and_state_dof_names (string_array) (opcional)","text":"<p>Especifica los dof_names o ejes para obtener la referencia y leer los estados. Este par\u00e1metro solo es relevante cuando los dof_names de estado son diferentes de los dof_names de comando, es decir, cuando se utiliza un controlador posterior.</p> <p>Read only: True</p> <p>Default: {}</p>"},{"location":"ros2control/#command_interface-string","title":"command_interface (string)","text":"<p>Nombre de la interfaz utilizada por el controlador para enviar comandos al hardware.</p> <p>Read only: True</p> <p>Default: \u201c\u201d</p>"},{"location":"ros2control/#reference_and_state_interfaces-string_array","title":"reference_and_state_interfaces (string_array)","text":"<p>Nombre de las interfaces utilizadas por el controlador para obtener los estados del hardware y los comandos de referencia. La segunda interfaz debe ser la derivada de la primera.</p> <p>Read only: True</p> <p>Default: {}</p> <p>La longitud es mayor que 0 y menor que 3.</p>"},{"location":"ros2control/#use_external_measured_states-bool","title":"use_external_measured_states (bool)","text":"<p>Usa estados externos desde un topic en lugar de las interfaces de estado.</p> <p>Default: false</p>"},{"location":"ros2control/#gainsp-double","title":"gains..p (double) <p>Ganancia proporcional del PID</p> <p>Default: 0.0</p>","text":""},{"location":"ros2control/#gainsi-double","title":"gains..i (double) <p>Ganancia integral del PID</p> <p>Default: 0.0</p>","text":""},{"location":"ros2control/#gainsd-double","title":"gains..d (double) <p>Ganancia derivativa del PID</p> <p>Default: 0.0</p>","text":""},{"location":"ros2control/#gainsantiwindup-bool","title":"gains..antiwindup (bool) <p>Funcionalidad anti-windup. Cuando est\u00e1 activada (true), limita el error integral para evitar el windup; de lo contrario, restringe la contribuci\u00f3n integral en la salida de control. Los valores i_clamp_max e i_clamp_min se aplican en ambos casos.</p> <p>Default: false</p>","text":""},{"location":"ros2control/#gainsi_clamp_max-double","title":"gains..i_clamp_max (double) <p>L\u00edmite superior de la parte integral.</p> <p>Default: 0.0</p>","text":""},{"location":"ros2control/#gainsi_clamp_min-double","title":"gains..i_clamp_min (double) <p>L\u00edmite inferior de la parte integral.</p> <p>Default: 0.0</p>","text":""},{"location":"ros2control/#gainsfeedforward_gain-double","title":"gains..feedforward_gain (double) <p>Ganancia para la parte feed-forward.</p> <p>Default: 0.0</p>","text":""},{"location":"ros2control/#gainsangle_wraparound-bool","title":"gains..angle_wraparound (bool) <p>Para articulaciones que giran completamente (es decir, son continuas). Normaliza el error de posici\u00f3n al rango de -\u03c0 a \u03c0</p> <p>Default: false</p>","text":""},{"location":"ros2control/#gainssave_i_term-bool","title":"gains..save_i_term (bool) <p>Indica si el t\u00e9rmino integral se mantiene despu\u00e9s de la reactivaci\u00f3n</p> <p>Default: true</p>","text":""},{"location":"ros2control/#ejemplo_4","title":"Ejemplo","text":"<p>Ejemplo de fichero de configuraci\u00f3n yaml.</p> Example <pre><code>test_pid_controller:\n    ros__parameters:\n        dof_names:\n        - joint1\n\n        command_interface: position\n\n        reference_and_state_interfaces: [\"position\"]\n\n        gains:\n            joint1: {p: 1.0, i: 2.0, d: 3.0, i_clamp_max: 5.0, i_clamp_min: -5.0}\n\ntest_pid_controller_angle_wraparound_on:\n    ros__parameters:\n        dof_names:\n        - joint1\n\n        command_interface: position\n\n        reference_and_state_interfaces: [\"position\"]\n\n        gains:\n            joint1: {p: 1.0, i: 2.0, d: 3.0, i_clamp_max: 5.0, i_clamp_min: -5.0, angle_wraparound: true}\n\ntest_pid_controller_with_feedforward_gain:\n    ros__parameters:\n        dof_names:\n        - joint1\n\n        command_interface: position\n\n        reference_and_state_interfaces: [\"position\"]\n\n        gains:\n            joint1: {p: 0.5, i: 0.0, d: 0.0, i_clamp_max: 5.0, i_clamp_min: -5.0, feedforward_gain: 1.0}\n\ntest_pid_controller_with_feedforward_gain_dual_interface:\n    ros__parameters:\n        dof_names:\n        - joint1\n        - joint2\n\n        command_interface: velocity\n\n        reference_and_state_interfaces: [\"position\", \"velocity\"]\n\n        gains:\n            joint1: {p: 0.5, i: 0.3, d: 0.4, i_clamp_max: 5.0, i_clamp_min: -5.0, feedforward_gain: 1.0}\n            joint2: {p: 0.5, i: 0.3, d: 0.4, i_clamp_max: 5.0, i_clamp_min: -5.0, feedforward_gain: 1.0}\n\ntest_save_i_term_off:\n    ros__parameters:\n        dof_names:\n        - joint1\n\n        command_interface: position\n\n        reference_and_state_interfaces: [\"position\"]\n\n        gains:\n            joint1: {p: 1.0, i: 2.0, d: 3.0, i_clamp_max: 5.0, i_clamp_min: -5.0, save_i_term: false}\n\ntest_save_i_term_on:\n    ros__parameters:\n        dof_names:\n        - joint1\n\n        command_interface: position\n\n        reference_and_state_interfaces: [\"position\"]\n\n        gains:\n            joint1: {p: 1.0, i: 2.0, d: 3.0, i_clamp_max: 5.0, i_clamp_min: -5.0, save_i_term: true}\n</code></pre>"}]}