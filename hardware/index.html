
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../conceptos_basicos/">
      
      
        <link rel="next" href="../controlador_propio/">
      
      
        
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Interfaz hardware - Ros2_control</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#interfaz-hardware" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Ros2_control" class="md-header__button md-logo" aria-label="Ros2_control" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Ros2_control
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Interfaz hardware
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Ros2_control" class="md-nav__button md-logo" aria-label="Ros2_control" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Ros2_control
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Introducción e instalación
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ros2control/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Los paquetes de ros2_control
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../conceptos_basicos/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Conceptos básicos de ros2_control
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Interfaz hardware
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Interfaz hardware
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#tipos-de-interfaz-hardware" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tipos de interfaz hardware
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Tipos de interfaz hardware">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#articulaciones" class="md-nav__link">
    <span class="md-ellipsis">
      
        Articulaciones
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensores" class="md-nav__link">
    <span class="md-ellipsis">
      
        Sensores
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpios" class="md-nav__link">
    <span class="md-ellipsis">
      
        GPIOs
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grupos-de-hardware" class="md-nav__link">
    <span class="md-ellipsis">
      
        Grupos de Hardware
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ejemplo" class="md-nav__link">
    <span class="md-ellipsis">
      
        Ejemplo
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#control-en-posicion-velocidad-y-aceleracion" class="md-nav__link">
    <span class="md-ellipsis">
      
        Control en posición, velocidad y aceleración
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#control-pid" class="md-nav__link">
    <span class="md-ellipsis">
      
        Control PID
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../controlador_propio/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Creación de un controlador propio
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#tipos-de-interfaz-hardware" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tipos de interfaz hardware
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Tipos de interfaz hardware">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#articulaciones" class="md-nav__link">
    <span class="md-ellipsis">
      
        Articulaciones
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensores" class="md-nav__link">
    <span class="md-ellipsis">
      
        Sensores
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpios" class="md-nav__link">
    <span class="md-ellipsis">
      
        GPIOs
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grupos-de-hardware" class="md-nav__link">
    <span class="md-ellipsis">
      
        Grupos de Hardware
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ejemplo" class="md-nav__link">
    <span class="md-ellipsis">
      
        Ejemplo
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#control-en-posicion-velocidad-y-aceleracion" class="md-nav__link">
    <span class="md-ellipsis">
      
        Control en posición, velocidad y aceleración
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#control-pid" class="md-nav__link">
    <span class="md-ellipsis">
      
        Control PID
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="interfaz-hardware">Interfaz hardware</h1>
<p>Después de que el controlador calcula la acción de control, su salida se envía a una interfaz hardware. Una interfaz hardware es un componente software que puede comunicarse con ROS2_control en un extremo y con uno o más dispositivos de hardware en el otro extremo.</p>
<p>Por ejemplo, supóngase que se tiene un sensor de posición que obtiene lecturas de datos de posición. Estas lecturas sin procesar son recibidas por la interfaz hardware y enviadas a un controlador que está escuchando esos datos. Cuando el controlador produce un nuevo comando, éste es recibido por la interfaz hardware. Luego, este comando se transforma en el formato de datos específico requerido y comprendido por el dispositivo hardware. Por lo tanto, se puede ver una interfaz hardware como un intermediario e intérprete que traduce los datos del hardware al controlador y viceversa.</p>
<p>En realidad, la interfaz hardware y ros2_control están acopladas mediante una interfaz de plugin. En términos técnicos, decimos que ros2_control implementa una "clase abstracta" y la interfaz hardware implementa la "clase derivada". De esta manera, el algoritmo de control no tiene que conocer los detalles específicos del hardware. Y como la interfaz de hardware es un plugin, no crea un nodo ROS2. En los siguientes apartados se irán viendo más detalles de todo esto y se aplicarán a nuestro robot de dos grados de libertad.</p>
<h2 id="tipos-de-interfaz-hardware">Tipos de interfaz hardware</h2>
<p>El framework ros2_control proporciona un conjunto de tipos de interfaces hardware que se pueden utilizar para implementar un componente de hardware para un robot o dispositivo específico. Las siguientes secciones describen los diferentes tipos de interfaces hardware y su uso.</p>
<p>El hardware en ros2_control se describe mediante un URDF. La definición se puede encontrar en el repositorio de <a href="https://github.com/ros-controls/ros2_control/blob/master/hardware_interface/include/hardware_interface/hardware_info.hpp">ros2_control</a>. Puedes consultar las estructuras definidas allí para ver qué atributos están disponibles para cada una de las etiquetas XML. A continuación se proporciona un ejemplo genérico que muestra la estructura (más abajo se describirá un nuevo ejemplo en la sección "ejemplo").</p>
<details class="example" open="open">
<summary>Example</summary>
<div class="highlight"><pre><span></span><code>&lt;ros2_control name=&quot;Name_of_the_hardware&quot; type=&quot;system&quot;&gt;
&lt;hardware&gt;
    &lt;plugin&gt;library_name/ClassName&lt;/plugin&gt;
    &lt;!-- added to hardware_parameters --&gt;
    &lt;param name=&quot;example_param&quot;&gt;value&lt;/param&gt;
&lt;/hardware&gt;
&lt;joint name=&quot;name_of_the_component&quot;&gt;
    &lt;command_interface name=&quot;interface_name&quot;&gt;
        &lt;!-- All of them are optional. `data_type` and `size` are used for GPIOs. Size is length of an array. --&gt;
        &lt;param name=&quot;min&quot;&gt;-1&lt;/param&gt;
        &lt;param name=&quot;max&quot;&gt;1&lt;/param&gt;
        &lt;param name=&quot;initial_value&quot;&gt;0.0&lt;/param&gt;
        &lt;param name=&quot;data_type&quot;&gt;&lt;/param&gt;
        &lt;param name=&quot;size&quot;&gt;5&lt;/param&gt;
        &lt;!-- Optional. Added to the key/value storage parameters --&gt;
        &lt;param name=&quot;own_param_1&quot;&gt;some_value&lt;/param&gt;
        &lt;param name=&quot;own_param_2&quot;&gt;other_value&lt;/param&gt;
    &lt;/command_interface&gt;
    &lt;!-- Short form to define StateInterface. Can be extended like CommandInterface. --&gt;
    &lt;state_interface name=&quot;position&quot;/&gt;
&lt;/joint&gt;
&lt;/ros2_control&gt;
</code></pre></div>
</details>
<h3 id="articulaciones">Articulaciones</h3>
<p>La etiqueta <code>&lt;joint&gt;</code> agrupa las interfaces asociadas con las articulaciones de los robots físicos y los actuadores. Tienen interfaces de comando (<code>&lt;command_interface name="interface_name"&gt;</code>) y de estado (<code>&lt;state_interface name="position"/&gt;</code>) para establecer los valores objetivo para el hardware y leer su estado actual.</p>
<p>Todas las articulaciones definidas en la etiqueta <code>&lt;ros2_control&gt;</code> deben estar presentes en el URDF recibido por el controller manager. Las interfaces de estado de las articulaciones pueden ser publicadas como un topic de ROS mediante el joint_state_broadcaster.</p>
<h3 id="sensores">Sensores</h3>
<p>La etiqueta <code>&lt;sensor&gt;</code> agrupa múltiples interfaces de estado que describen, por ejemplo, los estados internos del hardware. Dependiendo del tipo de sensor, existen algunos componentes semánticos específicos con emisores (broadcasters) proporcionados por ros2_controllers.</p>
<h3 id="gpios">GPIOs</h3>
<p>La etiqueta <code>&lt;gpio&gt;</code> se utiliza para describir puertos de entrada y salida de un dispositivo robótico que no pueden asociarse con ninguna articulación o sensor. El análisis de la etiqueta <code>&lt;gpio&gt;</code> es similar al de la etiqueta <code>&lt;joint&gt;</code>, teniendo interfaces de comando y de estado. La etiqueta debe tener al menos una etiqueta <code>&lt;command&gt;</code> o <code>&lt;state&gt;</code> como hija.</p>
<p>La palabra clave "gpio" se eligió por su generalidad. Aunque se usa estrictamente para señales digitales, describe cualquier señal eléctrica analógica, digital o valor físico. La etiqueta <code>&lt;gpio&gt;</code> puede usarse como hija de los tres tipos de componentes de hardware, es decir, sistema, sensor o actuador.</p>
<p>Debido a que los puertos implementados como <code>&lt;gpio&gt;</code> suelen ser muy específicos de la aplicación, no existe un emisor genérico dentro del marco ros2_control. Se debe implementar un controlador GPIO personalizado para cada aplicación. </p>
<h3 id="grupos-de-hardware">Grupos de Hardware</h3>
<p>Los grupos de componentes hardware sirven como un mecanismo organizacional crítico dentro de sistemas complejos, facilitando el manejo de errores y la tolerancia a fallos. Al agrupar componentes de hardware relacionados, como los actuadores dentro de un manipulador, los usuarios pueden establecer un marco unificado para la detección de errores y la respuesta.</p>
<p>Los grupos de componentes hardware juegan un papel vital en la propagación de errores a través de los componentes de hardware interconectados. Por ejemplo, en un sistema manipulador, agrupar los actuadores permite la propagación de errores. Si un actuador falla dentro del grupo, el error puede propagarse a los otros actuadores, señalando un posible problema en todo el sistema. De forma predeterminada, los errores de los actuadores se aíslan en su propio componente de hardware, lo que permite que el resto continúe funcionando sin verse afectado. En la configuración proporcionada de ros2_control, la etiqueta <code>&lt;group&gt;</code> dentro de cada bloque <code>&lt;ros2_control&gt;</code> significa el agrupamiento de componentes de hardware, habilitando los mecanismos de propagación de errores dentro del sistema.</p>
<h3 id="ejemplo">Ejemplo</h3>
<p>El siguiente ejemplo muestra cómo usar los diferentes tipos de interfaces hardware en un URDF de ros2_control. Estos pueden combinarse dentro de los diferentes tipos de componentes hardware (sistema, actuador, sensor) de la siguiente manera:</p>
<p>Sistema RRBot con múltiples interfaces GPIO</p>
<ul>
<li>Digital: 4 entradas y 2 salidas</li>
<li>Analógico: 2 entradas y 1 salida</li>
<li>Válvula de vacío en la brida (encendido/apagado)*</li>
</ul>
<details class="example" open="open">
<summary>Example</summary>
<div class="highlight"><pre><span></span><code>&lt;ros2_control name=&quot;RRBotSystemMutipleGPIOs&quot; type=&quot;system&quot;&gt;
    &lt;hardware&gt;
        &lt;plugin&gt;ros2_control_demo_hardware/RRBotSystemPositionOnlyHardware&lt;/plugin&gt;
        &lt;param name=&quot;example_param_hw_start_duration_sec&quot;&gt;2.0&lt;/param&gt;
        &lt;param name=&quot;example_param_hw_stop_duration_sec&quot;&gt;3.0&lt;/param&gt;
        &lt;param name=&quot;example_param_hw_slowdown&quot;&gt;2.0&lt;/param&gt;
    &lt;/hardware&gt;
    &lt;joint name=&quot;joint1&quot;&gt;
        &lt;command_interface name=&quot;position&quot;&gt;
            &lt;param name=&quot;min&quot;&gt;-1&lt;/param&gt;
            &lt;param name=&quot;max&quot;&gt;1&lt;/param&gt;
        &lt;/command_interface&gt;
        &lt;state_interface name=&quot;position&quot;/&gt;
    &lt;/joint&gt;
    &lt;joint name=&quot;joint2&quot;&gt;
        &lt;command_interface name=&quot;position&quot;&gt;
            &lt;param name=&quot;min&quot;&gt;-1&lt;/param&gt;
            &lt;param name=&quot;max&quot;&gt;1&lt;/param&gt;
        &lt;/command_interface&gt;
        &lt;state_interface name=&quot;position&quot;/&gt;
    &lt;/joint&gt;
    &lt;gpio name=&quot;flange_digital_IOs&quot;&gt;
        &lt;command_interface name=&quot;digital_output1&quot;/&gt;
        &lt;state_interface name=&quot;digital_output1&quot;/&gt;    &lt;!-- Needed to know current state of the output --&gt;
        &lt;command_interface name=&quot;digital_output2&quot;/&gt;
        &lt;state_interface name=&quot;digital_output2&quot;/&gt;
        &lt;state_interface name=&quot;digital_input1&quot;/&gt;
        &lt;state_interface name=&quot;digital_input2&quot;/&gt;
    &lt;/gpio&gt;
    &lt;gpio name=&quot;flange_analog_IOs&quot;&gt;
        &lt;command_interface name=&quot;analog_output1&quot;/&gt;
        &lt;state_interface name=&quot;analog_output1&quot;&gt;    &lt;!-- Needed to know current state of the output --&gt;
            &lt;param name=&quot;initial_value&quot;&gt;3.1&lt;/param&gt;  &lt;!-- Optional initial value for mock_hardware --&gt;
        &lt;/state_interface&gt;
        &lt;state_interface name=&quot;analog_input1&quot;/&gt;
        &lt;state_interface name=&quot;analog_input2&quot;/&gt;
    &lt;/gpio&gt;
    &lt;gpio name=&quot;flange_vacuum&quot;&gt;
        &lt;command_interface name=&quot;vacuum&quot;/&gt;
        &lt;state_interface name=&quot;vacuum&quot;/&gt;    &lt;!-- Needed to know current state of the output --&gt;
    &lt;/gpio&gt;
&lt;/ros2_control&gt;
</code></pre></div>
</details>
<h2 id="control-en-posicion-velocidad-y-aceleracion">Control en posición, velocidad y aceleración</h2>
<p>Una vez descritos los principales aspectos teóricos de los interfaces hardware, en este apartado se va a modificar el interfaz hardware de nuestro robot de dos grados de libertad para permitir el control en posición, velocidad y esfuerzo (recuerda que hasta ahora sólo permitía enviarle comandos de posición). Para ello, modificar el fichero rrbot.ros2_control.xacro que se encuentra en ros2_robot_sca/description/ros2_control para incluir las interfaces de velocidad y aceleración. Por ejemplo, la definición para joint1 debería ser la siguiente:</p>
<div class="highlight"><pre><span></span><code>    &lt;joint name=&quot;joint1&quot;&gt;
      &lt;command_interface name=&quot;position&quot;&gt;
        &lt;param name=&quot;min&quot;&gt;-1&lt;/param&gt;
        &lt;param name=&quot;max&quot;&gt;1&lt;/param&gt;
      &lt;/command_interface&gt;
      &lt;command_interface name=&quot;velocity&quot;&gt;
        &lt;param name=&quot;min&quot;&gt;-1&lt;/param&gt;
        &lt;param name=&quot;max&quot;&gt;1&lt;/param&gt;
      &lt;/command_interface&gt;
      &lt;command_interface name=&quot;effort&quot;&gt;
        &lt;param name=&quot;min&quot;&gt;-1&lt;/param&gt;
        &lt;param name=&quot;max&quot;&gt;1&lt;/param&gt;
      &lt;/command_interface&gt;
      &lt;state_interface name=&quot;position&quot;/&gt;
      &lt;state_interface name=&quot;velocity&quot;/&gt;
      &lt;state_interface name=&quot;effort&quot;/&gt;
    &lt;/joint&gt;
</code></pre></div>
<p>Se observa que se ha incluido las tres interfaces de comando (posición, velocidad y esfuerzo) para permitir que la articulación pueda ser accionada con comandos de posición, velocidad o esfuerzo. Además, se han incluido esas mismas interfaces de estado, lo que permitirá al controlador obtener una realimentación de las tres variables  y conocer su valor en cada momento. Repetir lo mismo para joint2. </p>
<p>A continuación modificar el fichero de configuración controller_configuration.yaml, que se encuentra en my_robot_bringup/config, para definir controladores de velocidad y esfuerzo. Para ello, editar el fichero controller_configuration.yaml y modificar la sección de controladores disponibles para que incluya los siguientes:</p>
<div class="highlight"><pre><span></span><code>    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

    forward_position_controller:
      type: position_controllers/JointGroupPositionController

    forward_velocity_controller:
      type: velocity_controllers/JointGroupVelocityController

    forward_effort_controller:
      type: effort_controllers/JointGroupEffortController
</code></pre></div>
<p>Se observa que se han definido tres controladores (adicionales al joint_state broadcaster). El controlador <code>forward_position controller</code> es un contrador de tipo <code>position_controllers/JointGroupPositionController</code>, por lo tanto, genera una acción de control de posición (aceptará también consignas de posición). El controlador <code>forward_velocity_controller</code> es de tipo <code>velocity_controllers/JointGroupVelocityController</code>. En este caso, genera una acción de control de velocidad (aceptando consignas de velocidad). Por último, el controlador <code>forward_effort_controller</code> es definido como <code>effort_controllers/JointGroupEffortController</code>, por lo tanto, implementa un controlador que manda dirctamente un esfuerzo articular.</p>
<p>Además, incluir la siguiente información en el fichero controller_configuration.yaml en la parte de propiedades de los controladores (borrar previamente la información que contenía el fichero .yaml en este apartado):</p>
<p><div class="highlight"><pre><span></span><code>forward_position_controller:
  ros__parameters:
    joints:
      - joint1
      - joint2
    interface_name: position

forward_velocity_controller:
  ros__parameters:
    joints:
      - joint1
      - joint2
    interface_name: velocity

forward_effort_controller:
  ros__parameters:
    joints:
      - joint1
      - joint2
    interface_name: effort
</code></pre></div>
Con este código se está asignando los tres controladores definidos anteriormente a las interfaces correspondientes.</p>
<p>Por último, habría que modificar el fichero my_robot.launch.py para cargar el controlador correspondiente (forward_position_controller, forward_velocity_controller o forward_effort_controller) para las articulaciones. Recordar que en el fichero launch se cargaba el controlador <code>forward_position_controller</code> mediante este código:
<div class="highlight"><pre><span></span><code>    robot_controller_spawner = Node(
        package=&quot;controller_manager&quot;,
        executable=&quot;spawner&quot;,
        arguments=[&quot;forward_position_controller&quot;, &quot;--param-file&quot;, robot_controllers],
    )
</code></pre></div>
Se va a modificar para que pueda especificarse el controlador mediante un parámetro. Esto puede conseguirse siguiendo los siguientes pasos:</p>
<p>Primero, añadir la información del nuevo parámetro en la definición del fichero launch:</p>
<div class="highlight"><pre><span></span><code>    <span class="n">declared_arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">DeclareLaunchArgument</span><span class="p">(</span>
            <span class="s2">&quot;robot_controller&quot;</span><span class="p">,</span>
            <span class="n">default_value</span><span class="o">=</span><span class="s2">&quot;forward_velocity_controller&quot;</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Robot controller to start.&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
</code></pre></div>
<p>En el apartado de inicialización de los argumentos incluir esta instrucción:
<div class="highlight"><pre><span></span><code><span class="n">robot_controller</span> <span class="o">=</span> <span class="n">LaunchConfiguration</span><span class="p">(</span><span class="s2">&quot;robot_controller&quot;</span><span class="p">)</span>
</code></pre></div></p>
<p>La llamada al controlador correpondiente se obtendrá mediante la siguiente instrucción (eliminar previamente la instrucción original <code>robot_controller_spawner = Node(...)</code>):
<div class="highlight"><pre><span></span><code>    <span class="n">robot_controller_spawner</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span>
        <span class="n">package</span><span class="o">=</span><span class="s2">&quot;controller_manager&quot;</span><span class="p">,</span>
        <span class="n">executable</span><span class="o">=</span><span class="s2">&quot;spawner&quot;</span><span class="p">,</span>
        <span class="n">arguments</span><span class="o">=</span><span class="p">[</span><span class="n">robot_controller</span><span class="p">,</span> <span class="s2">&quot;--param-file&quot;</span><span class="p">,</span> <span class="n">robot_controllers</span><span class="p">],</span>
    <span class="p">)</span>
</code></pre></div></p>
<p>Una vez hecho estos cambios, ejecutar los siguienes comandos y comprobar si todo está correcto:
<div class="highlight"><pre><span></span><code>cd ~/ros2_ws/ &amp;&amp; colcon build
source install/setup.bash
</code></pre></div>
se puede cargar el robot con el controlador correspondiente mediante:
<div class="highlight"><pre><span></span><code>ros2 launch my_robot_bringup my_robot.launch.py
</code></pre></div></p>
<p>Por defecto se ejecutará el velocity controller, puede cambiarse el controlador mediante la siguiente opción para el controlador de posición:
<div class="highlight"><pre><span></span><code>ros2 launch my_robot_bringup my_robot.launch.py robot_controller:=forward_position_controller
</code></pre></div>
O para el controlador de esfuerzo:
<div class="highlight"><pre><span></span><code>ros2 launch my_robot_bringup my_robot.launch.py robot_controller:=forward_effort_controller
</code></pre></div>
En otra terminal se pueden comprobar los interfaces disponibles mediante el siguiente comando:
<div class="highlight"><pre><span></span><code>ros2 control list_hardware_interfaces
</code></pre></div>
Se obtendrá lo siguiente si has cargado un controlador de posición:</p>
<p><img alt="robot simulado con rviz" src="../images/inthw.png" /></p>
<p>El marcador [claimed] de cada interfaz significa que un controlador tiene acceso al comando RRBot.</p>
<p>Verifica qué controladores están en ejecución mediante este comando:
<div class="highlight"><pre><span></span><code>ros2 control list_controllers
</code></pre></div>
Si se ha cargado el controlador de posición se obtiene lo siguiente:</p>
<p><img alt="robot simulado con rviz" src="../images/contrvec.png" /></p>
<p>Verifica cómo cambia esta salida si usas los diferentes argumentos de lanzamiento descritos anteriormente.</p>
<p>A continuación puedes enviar comandos a los controladores para mover las articulaciones del robot. El comando cambiará dependiendo del controlador cargado:</p>
<ul>
<li>Cuando uses el controlador forward_position_controller:
<div class="highlight"><pre><span></span><code>ros2 topic pub /forward_position_controller/commands std_msgs/msg/Float64MultiArray &quot;data:
- 0.5
- 0.5&quot;
</code></pre></div></li>
<li>Cuando uses el controlador forward_velocity_controller:
<div class="highlight"><pre><span></span><code>ros2 topic pub /forward_velocity_controller/commands std_msgs/msg/Float64MultiArray &quot;data:
- 5
- 5&quot;
</code></pre></div></li>
<li>Cuando uses el controlador forward_effort_controller:
<div class="highlight"><pre><span></span><code>ros2 topic pub /forward_effort_controller/commands std_msgs/msg/Float64MultiArray &quot;data:
- 10
- 10&quot;
</code></pre></div></li>
</ul>
<p>También puedes cambiar controladores durante la ejecución, lo que también cambia automáticamente el modo de comando. Para ello, vamos a suponer que estás utilizando un controlador tipo forward_velocity_controller. Recuerda que para eso puedes usar el siguiente comando:
<div class="highlight"><pre><span></span><code>ros2 launch my_robot_bringup my_robot.launch.py robot_controller:=forward_velocity_controller
</code></pre></div>
Ahora vamos a cambiarlo por un controlador de posición (forward_position_controller). Para ello, utilizaremos los dos siguientes comandos:
<div class="highlight"><pre><span></span><code>ros2 control load_controller forward_position_controller $(ros2 pkg prefix my_robot_bringup --share)/config/controller_configuration.yaml
</code></pre></div>
<div class="highlight"><pre><span></span><code>ros2 control set_controller_state forward_position_controller inactive
</code></pre></div></p>
<p>Ahora ya puedes cambiar controlador forward_velocity_controller por el forward_position_controller usando el siguiente comando:
<div class="highlight"><pre><span></span><code>ros2 control switch_controllers --deactivate forward_velocity_controller --activate forward_position_controller
</code></pre></div>
Ahora ya puedes mandarle al robot comandos de posición. Comprobar los interfaces y controladores con los siguientes comandos:
<div class="highlight"><pre><span></span><code>ros2 control list_controllers
</code></pre></div>
<div class="highlight"><pre><span></span><code>ros2 control list_hardware_interfaces
</code></pre></div>
<img alt="cambio de controlador" src="../cambcontr.png" /></p>
<div class="admonition note annotate">
<p class="admonition-title">Ejercicio</p>
<p>Experimentar con los distintos controladores y comprobar la diferencia de comportamiento dependiendo del tipo de controlador/comando utilizado.</p>
</div>
<h2 id="control-pid">Control PID</h2>
<p>En este apartado se incluirá un nuevo tipo de controlador (PID) y se añadirán los cambios y parámetros necesarios para su funcionamiento. En primer lugar, se considerará un controlador PID con referencia posición y acción de control velocidad. Los cambios necesarios a añadir al fichero controller_configuration.yaml para el nuevo controlador (pid_position_velocity_controller) son los que se muestran a continuación.</p>
<p>Primero añadir el tipo de controlador:
<div class="highlight"><pre><span></span><code>    pid_position_velocity_controller:
      type: pid_controller/PidController
</code></pre></div>
Y después incluir las características del controlador:
<div class="highlight"><pre><span></span><code>pid_position_velocity_controller:
  ros__parameters:
    dof_names:
      - joint1
      - joint2

    command_interface: velocity  # Acción de control será velocidad
    reference_interface: position  # Referencia será posición

    # Configuración de interfaces
    reference_and_state_interfaces: 
      - position

    # Ganancias PID para cada articulación
    gains:
      joint1:
        p: 10.0  # Ganancia proporcional
        i: 0.1   # Ganancia integral
        d: 0.01  # Ganancia derivativa
        i_clamp_max: 1.0
        i_clamp_min: -1.0
        antiwindup: true

      joint2:
        p: 10.0
        i: 0.1
        d: 0.01
        i_clamp_max: 1.0
        i_clamp_min: -1.0
        antiwindup: true
</code></pre></div>
Tras añadir el controlador pid_position_velocity_controller al fichero controller_configuration.yaml, se deberá probar si, utilizando este nuevo controlador, se alcanzan distintas posiciones de referencia. Para ello, se debe poder cargar el controlador con esta instrucción:
<div class="highlight"><pre><span></span><code>ros2 launch my_robot_bringup my_robot.launch.py robot_controller:=pid_position_velocity_controller
</code></pre></div>
Si se quiere, por ejemplo, que el robot alcance la posición articular (0.5 0.5) rad para ambas articulaciones se puede utilizar el siguiente comando:
<div class="highlight"><pre><span></span><code>ros2 topic pub /pid_position_velocity_controller/reference control_msgs/msg/MultiDOFCommand &quot;{
    dof_names: [&#39;joint1&#39;, &#39;joint2&#39;], 
    values: [0.5, 0.5], 
    values_dot: [0.0, 0.0]
}&quot;
</code></pre></div></p>
<div class="admonition note annotate">
<p class="admonition-title">Ejercicio</p>
<p>Tratar de ajustar correctamente las constantes del controlador PID para que el robot se posicione sin oscilaciones (probar que se alcance bien para distintas posiciones de referencia).</p>
<p>Para hacer el ajuste de las constantes proporcional, derivativa e integral, si ya tienes cargado el controlador PID, puedes cambiar estas constantes mediante comandos como los siguientes (desde otra terminal):</p>
<ul>
<li>Cambiar la ganancia P de joint1:
<div class="highlight"><pre><span></span><code>ros2 param set /pid_position_velocity_controller gains.joint1.p 15.0
</code></pre></div></li>
<li>Cambiar la ganancia I de joint2:
<div class="highlight"><pre><span></span><code>ros2 param set /pid_position_velocity_controller gains.joint2.i 0.2
</code></pre></div></li>
</ul>
<p>Por último, una forma de evaluar si el robot se está posicionando correctamente, es obtener una gráfica de la evolución de las articulaciones en los distintos experimentos. Una forma fácil de obtener las gráficas es usar una aplicación como plotjuggler. En esta aplicación se puede visualizar en tiempo real el estado de las articulaciones pulsando en start dentro del apartado Streaming (ROS2 Topic Subscriber) y seleccionar /joint_states. La posición de las articulaciones pueden monitorizarse en joint_states/position.</p>
</div>
<!--
 Para ello, se puede utilizar ROS 2 + rqt_plot:
 <div class="highlight"><pre><span></span><code>ros2 run rqt_plot rqt_plot /joint_states/position[0] rqt_plot /joint_states/position[0]
</code></pre></div>
Desde qt_plot se pueden introducir topics adicionales a plotear desde el cuadro de texto Topics.
-->

<div class="admonition note annotate">
<p class="admonition-title">Ejercicio</p>
<p>Diseñar un nuevo controlador con referencia posición y acción de control esfuerzo. Ajustarlo y probar que se alcancen bien distintas posiciones de referencia. Para ello, diseñar un script que permita representar la evolución de la posición de las articulaciones.</p>
</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": ["content.code.select", "content.code.copy"], "search": "../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>